<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>不听话的兔子君</title>
  
  <subtitle>那破云的光终会洒落，将有人迎向你的身侧</subtitle>
  <link href="https://naughtyrabbit.github.io/atom.xml" rel="self"/>
  
  <link href="https://naughtyrabbit.github.io/"/>
  <updated>2024-05-10T15:12:45.449Z</updated>
  <id>https://naughtyrabbit.github.io/</id>
  
  <author>
    <name>naughtyrabbit</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>个人随笔-意识流日记-2024.5.10</title>
    <link href="https://naughtyrabbit.github.io/2024/05/10/private-diary-4/"/>
    <id>https://naughtyrabbit.github.io/2024/05/10/private-diary-4/</id>
    <published>2024-05-10T14:28:10.000Z</published>
    <updated>2024-05-10T15:12:45.449Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>私人内容，请自重</p></blockquote><span id="more"></span><p><font face="楷体" color="SteelBlue" size="4"><p><strong> 嘛，今天晚上有个机试，然后笔试之前随便找找音乐，B站上无意看到这个https://www.bilibili.com/video/BV1ca4y117NV/?spm_id_from=333.1007.top_right_bar_window_history.content.click&amp;vd_source=9e285ebe1c470344e3eaafaa7f5fc6e2<br>原来是一首纯音乐，但是确实莫名伤感，之后又看了几个音乐区，然后莫名地哽咽，莫名地流泪，最后快要笔试了，不得已停下了自己的世界，也是一种讽刺，之后突然想发一句这样的空间或者朋友圈，“我想要在一个下雨快要7点的傍晚，听到一首没听过但是能让我停留的歌曲，可以有词，也可以没词，可以伤感或者开心，可以感动或者安逸，然后回忆着一些美好或者不美好，大哭一场，但是当一切准备好，我发现没有眼泪了，眼泪原来是一种不期而遇，我感觉哭的感觉很好，所以可能不常有吧”</strong><br><strong> 视频标题是《事实上 我爱着一切》，我自己是尝试这样，世界可能很多不美好，但是还是尝试去爱这个世界，至于怎样对我，那是世界的事，一直觉得了解了一件事之后还能保持自己的初心，不因这个而影响，还是很好的</strong><br><strong> 下面有一则热评是“你想结束的是痛苦，不是生命，不是吗？”，感觉是这样啊，经常会因为一些这样不错的评论区而感动，还有之前看到的那个，问手上的动脉在哪里，然后下面说他/她有“脉动”，楼主要不要，手上没有动脉的，虽然可能是编的，但是感觉还是不错这样，然后还有这样“希望每一个被伤了一遍又一遍的普通人都能够开心且快乐的活着[拥抱]”，这样“呐，亲爱的朋友啊，竟然要说爱着一切吗？那就拿实际行动来证明口牙，彷徨抑郁地坐在那里可是没有说服力的啊。放心大胆地活下去吧，无论是谁，我都会不求回报地爱你们哒。之所以酱紫做，问就是因为我也爱着一切呐[初音未来_大笑]”</strong><br><strong> 想到一些妖尾的那个，“你们这些反派啊，就不能稍微积极一点的活着吗，一天天的生啊死啊的”，虽然一点点中二，但是还是很不错这样，还有“可能有人喜欢孤独，但是没有人能忍受孤独”，老爷子还是很好人，抛开洗白什么的不谈，感觉单纯一点看这些动漫或者游戏也挺好的</strong><br><strong> 然后看了一个《古风入坑神曲》，勾起一些回忆这样，人可能还是怀旧的，看到一些熟悉的，至今仍然热爱的东西，一点点感动这样，之后听了张杰的《追风赶月的人》，然后似乎是一种高考中考这样的歌，虽然没有什么具体的感动的地方，但是感觉也是我的青春这样，也是一些不错回忆，然后也是在这里止不住的哭，在实验室工位上，还有不到10分钟笔试这样</strong><br><strong> 最后看了一个很厉害up的古风改编《喜羊羊与灰太狼主题曲》，以此作结吧，“有什么难题去牵绊我都不会去心伤”=&gt;“悟往者不谏，来着可追，便不觉有心伤”，拜拜哩( ´･･)ﾉ(._.`)</strong></p><p></font></p></p><p><img src="https://s21.ax1x.com/2024/05/10/pkZWVqP.jpg" alt="你好呀"></p><p>参考：<a href="https://naughtyrabbit.github.io/">https://naughtyrabbit.github.io/</a></p>]]></content>
    
    
    <summary type="html">仅供自己观看，请自重</summary>
    
    
    
    <category term="私人日记" scheme="https://naughtyrabbit.github.io/categories/%E7%A7%81%E4%BA%BA%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="私人日记" scheme="https://naughtyrabbit.github.io/tags/%E7%A7%81%E4%BA%BA%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>个人随笔-意识流日记-2024.4.2</title>
    <link href="https://naughtyrabbit.github.io/2024/04/03/private-diary-3/"/>
    <id>https://naughtyrabbit.github.io/2024/04/03/private-diary-3/</id>
    <published>2024-04-03T11:04:26.000Z</published>
    <updated>2024-04-03T11:56:22.869Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>私人内容，请自重</p></blockquote><span id="more"></span><p><font face="楷体" color="SteelBlue" size="4"><p><strong> 出差回西安，下了高铁，直奔乘坐出租车的地方，路上不少揽客的师傅，操着浓厚的本地口音，说着不用等直接上车之类的话，似乎也可以去坐，但是为什么不理睬呢，也懒得去想了，能拉到几个人呢在这，或者真的能拉到人吗？想着这些，已经到了“官方”出租车排队的地方。</strong><br><strong> 还感冒着，鼻塞加上眼睛痛，祈祷着到我的时候是一辆电车，少些汽油味，可能就不会晕车，运气很好，是一辆绿色车牌的车，上车前发了条信息，在车上会晕车看不了手机。</strong><br><strong> “师傅，去xx南校区”，司机似乎不知道这个学校，我重复了一遍，司机一边开车出高铁站，一边打开导航软件搜索起来。</strong><br><strong> “哪个校区？”，司机问。</strong><br><strong> “南校区”，我补充道，“东门”。</strong><br><strong> “已开始导航，全程xxx公里，预计52分钟”，传来开始导航的信号，我闭上眼睛，驶出地上之前有个很大的弯，感受着推背感，只有我一个人，便任由身体摆动，看着路边的风景，回忆着出差前来高铁站时也是一样的景色，熟悉的几个电线杆和几栋比较标志性的建筑，一起出行的几个或者回家或者去其他地方旅游，只有我回来西安。</strong><br><strong> “前方路段有交通事故拥堵，预计通行时间15分钟”，堵车了，饭还没吃，晕车体质加上感冒眼睛难受，我再次闭上眼睛</strong><br><strong> “今天运气很好，拉了两趟就够班费了（？），一趟从城西到高铁站65块，现在从高铁站到长安也能赚不少”，司机师傅操着方言发了个语音给谁，似乎在说今天跑了两趟车就挣了不少钱什么的，不清楚“班费”是个什么，可能是出租车公司的租车费用，感觉跑出租全是这种小长途单子确实很舒服，不麻烦，一个人也省油省电</strong><br><strong> “真不错，这不仅班费够了，电费也够了，多的就是你的零花钱”，似乎是对面回了个语音，听声音是个女声，大抵是司机的妻子吧；“xx保佑，这样就很不错啦”，妻子补充了一句什么什么保佑，没听清是佛祖还是安拉什么的，很朴实一家子呀，感觉很不错的生活，两口子就这么过着，跑出租应该也不会挣很多钱，但是两个人依然满足，互相感觉也很和谐，还怪叫人羡慕的。司机继续开着车，似乎没有继续了</strong><br><strong> “感谢您提供的事故发生车道信息，……”，车还在堵着，似乎到了发生事故的地方，司机在导航上上报了具体的事故发生车道。“虽然前方拥堵，但您依然在最优路线”，导航来了一句这个哈哈，车在缓缓移动着，逐渐驶出堵车路段</strong><br><strong> “您提供的事故发生车道信息，已给57位司机提供了帮助，为您增加100点xx值”</strong><br><strong> “您提供的事故发生车道信息，已给140位司机提供了帮助，……”</strong><br><strong> 人生虽苦，亦有美好，天逐渐黑了起来，远处路灯闪烁着亮黄色的灯光。</strong></p><p></font></p></p><p><img src="https://s21.ax1x.com/2024/04/03/pFHvpfU.jpg" alt="你好呀"></p>]]></content>
    
    
    <summary type="html">仅供自己观看，请自重</summary>
    
    
    
    <category term="私人日记" scheme="https://naughtyrabbit.github.io/categories/%E7%A7%81%E4%BA%BA%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="私人日记" scheme="https://naughtyrabbit.github.io/tags/%E7%A7%81%E4%BA%BA%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>你的第一个openCL程序————向量加</title>
    <link href="https://naughtyrabbit.github.io/2023/08/17/opencl-first-program/"/>
    <id>https://naughtyrabbit.github.io/2023/08/17/opencl-first-program/</id>
    <published>2023-08-17T11:57:50.000Z</published>
    <updated>2023-08-20T02:01:44.967Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>介绍openCL程序编写流程，包括编译执行过程,以向量加为例，走完一个基本的流程，了解其过程。参考：<a href="https://www.eriksmistad.no/getting-started-with-opencl-and-gpu-computing/">https://www.eriksmistad.no/getting-started-with-opencl-and-gpu-computing/</a></p></blockquote><span id="more"></span>  <h3 id="openCL介绍">openCL介绍</h3><p> Open CL（开放计算语言）是一个新的框架，用于编写在不同供应商（AMD、Intel、ATI、Nvidia等）的不同计算设备（如CPU和GPU）上并行执行的程序。该框架定义了一种编写“内核”的语言。这些内核是在不同计算设备上运行的函数。在这篇文章中，我解释了如何开始使用Open CL，以及如何制作一个小型的Open CL程序，该程序将并行计算两个列表的总和。<br> 以向量加为例，A和B是两个等长的向量，将其相加，得到向量C，如图1所示<br><img src="https://s1.ax1x.com/2023/08/18/pP1OBTI.png" alt="图1 向量加示意图"><br> 通常的做法是利用for循环遍历A，B两个向量，对每一个元素做相加，得到向量C的每一个元素。显然，这么做的时间复杂度是O(n)，而实际上在该例子中，每一次迭代的计算都是各自不相关的，因此可以同时进行，并行以提高效率，如果有n个核，那并行起来时间复杂度就是O(1)。<br> 为了使openCL完成以上过程，需要两部分代码：</p><ol><li>openCL内核代码：在计算设备上运行</li><li>主机（host）代码：在主机上运行，调用openCL代码执行</li></ol><h3 id="一、环境准备">一、环境准备</h3><p> 以C程序为例（显然应该安装了gcc编译器），需包含openCL库，如果缺少该库（通常如果安装了cuda则会包含openCL库），在ubuntu上，可以通过包管理器直接安装：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> ocl-icd-opencl-dev<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="二、程序编写">二、程序编写</h3><p> 如前文所述，openCL代码通常由openCL内核代码核主机代码组成，下面分别介绍二者，并给出完整示例代码及分析。</p><h4 id="2-1-kernel编写">2.1 kernel编写</h4><p> 内核是用OpenCL语言编写的，它是C的一个子集，包含了许多数学和向量函数。执行向量加法运算的内核定义如下。文件命名为：<a href="http://vectorAddition.cl">vectorAddition.cl</a></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">__kernel <span class="token keyword">void</span> <span class="token function">vector_add</span><span class="token punctuation">(</span>__global <span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>A<span class="token punctuation">,</span> __global <span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>B<span class="token punctuation">,</span> __global <span class="token keyword">int</span> <span class="token operator">*</span>C<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     <span class="token comment">// Get the index of the current element to be processed</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">get_global_id</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// Do the operation</span>    C<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> B<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 内核也有注释，基本和C语言一样，传入A,B,C数组指针，然后根据索引对对应位置相加得到向量C的结果。</p><h4 id="2-2-主机程序编写">2.2 主机程序编写</h4><p> 主机程序控制计算设备上内核的执行。主机程序是用C编写的，但存在用于C++和Python等其他语言的绑定。Open CL API是在CL.h（或apple的opencl.h）头文件中定义的。下面是在计算设备上执行上面内核的主机程序的代码。主机程序命名为：main.c ; 主要步骤如下：</p><h5 id="2-2-1-OpenCL的编程步骤">2.2.1 OpenCL的编程步骤</h5><ol><li>Discover and initialize the platforms<br>调用clGetPlatformIDs函数获取platform信息。</li><li>Discover and initialize the devices<br>调用clGetDeviceIDs函数获取。并且可以简单修改参数，比如CL_DEVICE_TYPE_GPU换成CL_DEVICE_TYPE_CPU来更换openCL内核代码执行设备</li><li>Create  a context(调用clCreateContext函数）<br>上下文context可能会管理多个设备device。</li><li>Create a command queue(调用clCreateCommandQueue函数）<br>一个设备device对应一个command queue。<br>上下文conetxt将命令发送到设备对应的command queue，设备就可以执行命令队列里的命令。</li><li>Create device buffers(调用clCreateBuffer函数）<br>Buffer中保存的是数据对象，就是设备执行程序需要的数据保存在其中。<br>Buffer由上下文conetxt创建，这样上下文管理的多个设备就会共享Buffer中的数据。</li><li>Write host data to device buffers(调用clEnqueueWriteBuffer函数）</li><li>Create and compile the program<br>创建程序对象，程序对象就代表你的程序源文件或者二进制代码数据。</li><li>Create the kernel(调用clCreateKernel函数）<br>根据你的程序对象，生成kernel对象，表示设备程序的入口。</li><li>Set the kernel arguments(调用clSetKernelArg函数）</li><li>Configure the work-item structure(设置worksize）<br>配置work-item的组织形式（维数，group组成等）</li><li>Enqueue the kernel for execution(调用clEnqueueNDRangeKernel函数）<br>将kernel对象，以及 work-item参数放入命令队列中进行执行。</li><li>Read  the output buffer back to the host(调用clEnqueueReadBuffer函数）</li><li>Release OpenCL resources（至此结束整个运行过程）</li></ol><p> 下面是一些具体的对应本程序的步骤</p><ul><li>获取有关平台和计算机上可用设备的信息（第42行）</li><li>选择要在执行中使用的设备（第43行）</li><li>创建Open CL上下文（第47行）</li><li>创建命令队列（第50行）</li><li>创建内存缓冲区对象（第53-58行）</li><li>将数据（列表A和B）传输到设备上的存储器缓冲区（线路61-64）</li><li>创建程序对象（第67行）</li><li>加载内核源代码（第24-35行）并对其进行编译（第71行）（在线执行）或加载预编译的二进制Open CL程序（离线执行）</li><li>创建内核对象（第74行）</li><li>设置内核参数（第77-79行）</li><li>执行内核（第84行）</li><li>读取内存对象。在这种情况下，我们从计算设备读取列表C（第88-90行）</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">__APPLE__</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;OpenCL/opencl.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;CL/cl.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAX_SOURCE_SIZE</span> <span class="token expression"><span class="token punctuation">(</span><span class="token number">0x100000</span><span class="token punctuation">)</span></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// Create the two input vectors</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">const</span> <span class="token keyword">int</span> LIST_SIZE <span class="token operator">=</span> <span class="token number">1024</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token operator">*</span>A <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">*</span>LIST_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token operator">*</span>B <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">*</span>LIST_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> LIST_SIZE<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        A<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>        B<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> LIST_SIZE <span class="token operator">-</span> i<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// Load the kernel source code into the array source_str</span>    FILE <span class="token operator">*</span>fp<span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>source_str<span class="token punctuation">;</span>    <span class="token class-name">size_t</span> source_size<span class="token punctuation">;</span>    fp <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">"vector_add_kernel.cl"</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>fp<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"Failed to load kernel.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    source_str <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>MAX_SOURCE_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>    source_size <span class="token operator">=</span> <span class="token function">fread</span><span class="token punctuation">(</span> source_str<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> MAX_SOURCE_SIZE<span class="token punctuation">,</span> fp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">fclose</span><span class="token punctuation">(</span> fp <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// Get platform and device information</span>    cl_platform_id platform_id <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    cl_device_id device_id <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>       cl_uint ret_num_devices<span class="token punctuation">;</span>    cl_uint ret_num_platforms<span class="token punctuation">;</span>    cl_int ret <span class="token operator">=</span> <span class="token function">clGetPlatformIDs</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>platform_id<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ret_num_platforms<span class="token punctuation">)</span><span class="token punctuation">;</span>    ret <span class="token operator">=</span> <span class="token function">clGetDeviceIDs</span><span class="token punctuation">(</span> platform_id<span class="token punctuation">,</span> CL_DEVICE_TYPE_GPU<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span>             <span class="token operator">&amp;</span>device_id<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ret_num_devices<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// Create an OpenCL context</span>    cl_context context <span class="token operator">=</span> <span class="token function">clCreateContext</span><span class="token punctuation">(</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>device_id<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>ret<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// Create a command queue</span>    cl_command_queue command_queue <span class="token operator">=</span> <span class="token function">clCreateCommandQueue</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> device_id<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>ret<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// Create memory buffers on the device for each vector </span>    cl_mem a_mem_obj <span class="token operator">=</span> <span class="token function">clCreateBuffer</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> CL_MEM_READ_ONLY<span class="token punctuation">,</span>             LIST_SIZE <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>ret<span class="token punctuation">)</span><span class="token punctuation">;</span>    cl_mem b_mem_obj <span class="token operator">=</span> <span class="token function">clCreateBuffer</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> CL_MEM_READ_ONLY<span class="token punctuation">,</span>            LIST_SIZE <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>ret<span class="token punctuation">)</span><span class="token punctuation">;</span>    cl_mem c_mem_obj <span class="token operator">=</span> <span class="token function">clCreateBuffer</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> CL_MEM_WRITE_ONLY<span class="token punctuation">,</span>             LIST_SIZE <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>ret<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// Copy the lists A and B to their respective memory buffers</span>    ret <span class="token operator">=</span> <span class="token function">clEnqueueWriteBuffer</span><span class="token punctuation">(</span>command_queue<span class="token punctuation">,</span> a_mem_obj<span class="token punctuation">,</span> CL_TRUE<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span>            LIST_SIZE <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">,</span> A<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ret <span class="token operator">=</span> <span class="token function">clEnqueueWriteBuffer</span><span class="token punctuation">(</span>command_queue<span class="token punctuation">,</span> b_mem_obj<span class="token punctuation">,</span> CL_TRUE<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span>             LIST_SIZE <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">,</span> B<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// Create a program from the kernel source</span>    cl_program program <span class="token operator">=</span> <span class="token function">clCreateProgramWithSource</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span>             <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>source_str<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token class-name">size_t</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>source_size<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ret<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// Build the program</span>    ret <span class="token operator">=</span> <span class="token function">clBuildProgram</span><span class="token punctuation">(</span>program<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>device_id<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// Create the OpenCL kernel</span>    cl_kernel kernel <span class="token operator">=</span> <span class="token function">clCreateKernel</span><span class="token punctuation">(</span>program<span class="token punctuation">,</span> <span class="token string">"vector_add"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>ret<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// Set the arguments of the kernel</span>    ret <span class="token operator">=</span> <span class="token function">clSetKernelArg</span><span class="token punctuation">(</span>kernel<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>cl_mem<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>a_mem_obj<span class="token punctuation">)</span><span class="token punctuation">;</span>    ret <span class="token operator">=</span> <span class="token function">clSetKernelArg</span><span class="token punctuation">(</span>kernel<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>cl_mem<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>b_mem_obj<span class="token punctuation">)</span><span class="token punctuation">;</span>    ret <span class="token operator">=</span> <span class="token function">clSetKernelArg</span><span class="token punctuation">(</span>kernel<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>cl_mem<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>c_mem_obj<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// Execute the OpenCL kernel on the list</span>    <span class="token class-name">size_t</span> global_item_size <span class="token operator">=</span> LIST_SIZE<span class="token punctuation">;</span> <span class="token comment">// Process the entire lists</span>    <span class="token class-name">size_t</span> local_item_size <span class="token operator">=</span> <span class="token number">64</span><span class="token punctuation">;</span> <span class="token comment">// Process in groups of 64</span>    ret <span class="token operator">=</span> <span class="token function">clEnqueueNDRangeKernel</span><span class="token punctuation">(</span>command_queue<span class="token punctuation">,</span> kernel<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span>             <span class="token operator">&amp;</span>global_item_size<span class="token punctuation">,</span> <span class="token operator">&amp;</span>local_item_size<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// Read the memory buffer C on the device to the local variable C</span>    <span class="token keyword">int</span> <span class="token operator">*</span>C <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">*</span>LIST_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>    ret <span class="token operator">=</span> <span class="token function">clEnqueueReadBuffer</span><span class="token punctuation">(</span>command_queue<span class="token punctuation">,</span> c_mem_obj<span class="token punctuation">,</span> CL_TRUE<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span>             LIST_SIZE <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">,</span> C<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// Display the result to the screen</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> LIST_SIZE<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d + %d = %d\n"</span><span class="token punctuation">,</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> B<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> C<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// Clean up</span>    ret <span class="token operator">=</span> <span class="token function">clFlush</span><span class="token punctuation">(</span>command_queue<span class="token punctuation">)</span><span class="token punctuation">;</span>    ret <span class="token operator">=</span> <span class="token function">clFinish</span><span class="token punctuation">(</span>command_queue<span class="token punctuation">)</span><span class="token punctuation">;</span>    ret <span class="token operator">=</span> <span class="token function">clReleaseKernel</span><span class="token punctuation">(</span>kernel<span class="token punctuation">)</span><span class="token punctuation">;</span>    ret <span class="token operator">=</span> <span class="token function">clReleaseProgram</span><span class="token punctuation">(</span>program<span class="token punctuation">)</span><span class="token punctuation">;</span>    ret <span class="token operator">=</span> <span class="token function">clReleaseMemObject</span><span class="token punctuation">(</span>a_mem_obj<span class="token punctuation">)</span><span class="token punctuation">;</span>    ret <span class="token operator">=</span> <span class="token function">clReleaseMemObject</span><span class="token punctuation">(</span>b_mem_obj<span class="token punctuation">)</span><span class="token punctuation">;</span>    ret <span class="token operator">=</span> <span class="token function">clReleaseMemObject</span><span class="token punctuation">(</span>c_mem_obj<span class="token punctuation">)</span><span class="token punctuation">;</span>    ret <span class="token operator">=</span> <span class="token function">clReleaseCommandQueue</span><span class="token punctuation">(</span>command_queue<span class="token punctuation">)</span><span class="token punctuation">;</span>    ret <span class="token operator">=</span> <span class="token function">clReleaseContext</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">free</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">free</span><span class="token punctuation">(</span>B<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">free</span><span class="token punctuation">(</span>C<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="三、编译运行">三、编译运行</h3><p> 如果Open CL头文件和库文件位于其适当的文件夹（/usr/include和/usr/lib）中，则以下命令将编译vector Addition程序。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gcc main.c -o vectorAddition -l OpenCL<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 运行结果如图2<br><img src="https://s1.ax1x.com/2023/08/19/pP3WI6x.png" alt="图2 运行结果"></p><p>参考：<a href="https://naughtyrabbit.github.io/">https://naughtyrabbit.github.io/</a></p>]]></content>
    
    
    <summary type="html">介绍openCL程序编写流程，包括编译执行过程</summary>
    
    
    
    <category term="openCL" scheme="https://naughtyrabbit.github.io/categories/openCL/"/>
    
    
    <category term="openCL" scheme="https://naughtyrabbit.github.io/tags/openCL/"/>
    
  </entry>
  
  <entry>
    <title>那些句子</title>
    <link href="https://naughtyrabbit.github.io/2023/03/29/beauty-words/"/>
    <id>https://naughtyrabbit.github.io/2023/03/29/beauty-words/</id>
    <published>2023-03-29T04:42:13.000Z</published>
    <updated>2023-04-07T13:08:13.901Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>记录一些有意思的话</p></blockquote><span id="more"></span><h3 id="一、from-others">一、from others</h3><h4 id="1-棒！">1. 棒！</h4><p><font face="楷体" color="SteelBlue"><center>  <p><strong>陪我走走吧, 趁天还没亮，浓雾里还透着光 ----右友</strong></p></center></font></p>  <h4 id="2-这，这有点意思啊，有点意思">2. 这，这有点意思啊，有点意思</h4><p><font face="楷体" color="SteelBlue"><center>  <p><strong>陪我走走吧, 趁天还没亮，浓雾里还透着光 ----右友</strong><br><strong>有些人，自己像在水里一般宁静，却使别人站在暴风雨中 ----黑暗荣耀</strong></p></center></font></p> <p><img src="https://s.im5i.com/2021/05/21/S0qUp.jpg" alt="好康的壁纸">这里放图片链接，中括号里面是描述</p><p>参考：<a href="https://naughtyrabbit.github.io/">https://naughtyrabbit.github.io/</a></p>]]></content>
    
    
    <summary type="html">仅供自己观看，请自重</summary>
    
    
    
    <category term="私人日记" scheme="https://naughtyrabbit.github.io/categories/%E7%A7%81%E4%BA%BA%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="私人日记" scheme="https://naughtyrabbit.github.io/tags/%E7%A7%81%E4%BA%BA%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>个人随笔-意识流日记-2022.11.27</title>
    <link href="https://naughtyrabbit.github.io/2022/11/27/private-diary-2/"/>
    <id>https://naughtyrabbit.github.io/2022/11/27/private-diary-2/</id>
    <published>2022-11-27T14:18:22.000Z</published>
    <updated>2022-11-27T14:42:25.826Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span> <p><font face="楷体" color="SteelBlue" size="4"> <p><strong> 观彻夜之歌有感</strong><br><strong> 彻夜之歌是最近在看的一个动漫啊，男主夜守光白天不上学，晚上睡不着，在街上闲逛，遇到了名为七草荠的吸血鬼美少女，一番熟悉后，小光产生了人生中第一个明确的目标------“成为吸血鬼”，但成为吸血鬼需要成为吸血鬼的眷属，也就是喜欢上小荠后被小荠吸血。</strong><br><strong> 昨天刚看到一集，男主夜守光在女主家遇到了前来按摩的上班族ol（吸血鬼的生活费就是按摩赚来的），在帮ol按摩的过程中，谈到了自己对“夜晚”的喜爱，对凌晨空荡的马路，走在马路中央，仿佛世界是自己的一样，勾起了ol对年少时的回忆，同时，想到自己现在凌晨还要被老板喊回去加班，大哭了一场</strong><br><strong> 半夜走在马路中央，不管是唱歌还是大叫，这种掌控了世界的感觉最近一次是在本科一次回家的过程中，为了完成暑期实践，去了黄山，2，3天玩完了之后各奔东西，我和另外一个舍友（磊子哥）一起，因为火车出发还有4，5个小时，火车站又没有很多插座，便决定去最近的KFC蹭个位置，当时也有12点多了，路上也确实没什么人，走在路上，手机放着歌，回忆起来确实很舒服啊，有种怀念的感觉，你也向往自由吗？----艾伦-耶格尔，#_#</strong><br><strong> 再往回倒，就是小学时候了，可能更早，忘了，或者是暑假的时候，因为记着是随着爸妈一起去隔壁镇找大伯他们之类的打麻将，我一个人在家也没意思，就带我去了，他们在打麻将，我要么玩手机，要么看电视（那时候记得手机还没什么玩的，主要还是看电视，记得好像那段时间看了不少柯南），然后就是打完得凌晨1，2点了，再往回走，路上得半个小时到1个小时，然后路上也是基本上没什么人，回想起来感觉也挺不错的。</strong><br><strong> 再往回倒，就不知道是什么时候了，我记忆里总是有这么个画面，我爸开着三轮马自达，车厢里铺着被子啥的，我躺在里面，看着天上，往老家回。因为爸妈在江苏打工，老家是安徽的，记得一起过年都得年前几天或者30晚这么往家赶。当然也可能是我一直在想象这个场景，导致我认为这是真实发生的，过年往家赶是真的，是不是有这个场景就不得而知了。但是想想也挺浪漫的，躺在马自达里，抬头看着星空，当然，现在小孩可能也没这机会了，一是马自达不让开了，二是星空也少见了，三是现在夜生活也确实很晚了，半夜11点左右，估计马路上车还挺多，只会觉得汽笛声聒噪。没有星空确实是一件挺可惜的事，少了一份浪漫。</strong><br></font></p><br><img src="https://s.im5i.com/2021/05/21/S0qUp.jpg" alt="好康的壁纸"><br>参考：<a href="https://naughtyrabbit.github.io/">https://naughtyrabbit.github.io/</a></p>]]></content>
    
    
    <summary type="html">仅供自己观看，请自重</summary>
    
    
    
    <category term="私人日记" scheme="https://naughtyrabbit.github.io/categories/%E7%A7%81%E4%BA%BA%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="私人日记" scheme="https://naughtyrabbit.github.io/tags/%E7%A7%81%E4%BA%BA%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>x86服务器配置教程-张九同学长</title>
    <link href="https://naughtyrabbit.github.io/2022/11/24/x86_server_setup/"/>
    <id>https://naughtyrabbit.github.io/2022/11/24/x86_server_setup/</id>
    <published>2022-11-24T03:08:51.000Z</published>
    <updated>2022-11-27T14:20:36.475Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>基于docker的服务器管理</p></blockquote><span id="more"></span><h1>x86服务器配置教程</h1><p><strong>基本信息：</strong></p><p><strong>板卡：2080ti、寒武纪npu</strong></p><p><strong>架构：x86_64</strong></p><p><strong>系统：Ubuntu18.04</strong></p><h2 id="一、docker"><strong>一、docker</strong></h2><h3 id="1-1、安装docker">1.1、安装docker</h3><p>​    apt install <a href="http://docker.io">docker.io</a></p><h4 id="1-1-2、新建docker用户组">1.1.2、新建docker用户组</h4><p>​docker守护进程启动的时候，会默认赋予名字为docker的用户组读写Unix socket的权限，因此只要创建docker用户组，并将当前用户加入到docker用户组中，那么当前用户就有权限访问Unix socket了，进而也就可以执行docker相关命令</p><pre class="line-numbers language-none"><code class="language-none">sudo groupadd docker   #添加docker用户组sudo gpasswd -a username docker   #将登陆用户加入到docker用户组中newgrp docker   #更新用户组<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="1-1-3、测试docker">1.1.3、测试docker</h4><p>docker version</p><p>docker run hello-world</p><h3 id="1-2、docker-拉取镜像">1.2、docker 拉取镜像</h3><h4 id="1-2-1、docker命令">1.2.1、docker命令</h4><p>进入容器命令：</p><pre class="line-numbers language-none"><code class="language-none">docker exec -it 容器ID &#x2F;bin&#x2F;bash <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​或者</p><pre class="line-numbers language-none"><code class="language-none">docker exec -it 容器的name bash<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​退出容器命令</p><pre class="line-numbers language-none"><code class="language-none">exit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​删除docker命令</p><pre class="line-numbers language-none"><code class="language-none">docker rm dockerID<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>删除镜像命令</p><pre class="line-numbers language-none"><code class="language-none">docker rmi imagesID<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="1-2-2、-docker拉取gitea">1.2.2、  docker拉取gitea</h4><pre class="line-numbers language-none"><code class="language-none">docker pull gitea&#x2F;gitea:latest<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-docker" data-language="docker"><code class="language-docker">sudo mkdir -p /home/zjt/GiteaDocker<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-docker" data-language="docker"><code class="language-docker"><span class="token comment">#运行docker容器</span>docker run -d --name=gitea -p 10022:22 -p 10080:3000 -v /home/zjt/GiteaDocker:/data gitea/gitea:latest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="1-2-3、docker拉取mysql">1.2.3、docker拉取mysql</h4><p>docker pull  mysql</p><pre class="line-numbers language-docker" data-language="docker"><code class="language-docker">dock docker run -itd --name mysql-test -p 3306:3306 -e MYSQL_ROOT_PASSWORD=xxxxxx mysql<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>-p 3306:3306</strong> ：映射容器服务的 3306 端口到宿主机的 3306 端口，外部主机可以直接通过 <strong>宿主机ip:3306</strong> 访问到 MySQL 的服务。</li><li>**MYSQL_ROOT_PASSWORD=xxxxxx：设置 MySQL 服务 root 用户的密码。</li></ul><h3 id="1-3-docker自动上传镜像">1.3 docker自动上传镜像</h3><h4 id="1-3-1-编写makefile文件">1.3.1 编写makefile文件</h4><pre class="line-numbers language-none"><code class="language-none">cd &#x2F;home&#x2F;zjt&#x2F;docker_filevim Makefile<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>下面是makefile文件内容</p><pre class="line-numbers language-none"><code class="language-none">tag:        docker tag mysql:5.7.27 1008zjt&#x2F;mysqlpull:tag        docker push 1008zjt&#x2F;mysql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-3-2-编写shell脚本pull-sh">1.3.2 <a href="http://xn--shellpull-zq3ow21q175c3qf.sh">编写shell脚本pull.sh</a></h4><p>内容如下:</p><pre class="line-numbers language-none"><code class="language-none">make pull<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="1-3-3-使用crontab-自动运行脚本">1.3.3 使用crontab 自动运行脚本</h4><p>1、首先crontab -e 编辑定时任务</p><p><img src="https://img2018.cnblogs.com/common/380239/202002/380239-20200205121254532-149023628.png" alt="img"></p><p>2、按 【<strong>Ctrl + X</strong>】，如果没有改动会直接退出，否则会先跳到下一个界面<br>（这一步也可以先使用【Ctrl + O】写入，再用【Ctrl + X】退出）</p><p><img src="https://img2018.cnblogs.com/common/380239/202002/380239-20200205121301891-1458908135.png" alt="img"></p><p>3、直接按 【<strong>Y</strong>】，再进入下一个界面，如下图：<br>（我印象里以前不是这样子的啊，可能是老了，记错了）</p><p><img src="https://img2018.cnblogs.com/common/380239/202002/380239-20200205121312714-996260296.png" alt="img"></p><p>4、【<strong>Ctrl + M</strong>】 可以保存</p><h3 id="1-4-docker自启动">1.4 docker自启动</h3><p>1.5 docker 镜像位置</p><p>docker info</p><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210604153325446.png" alt="image-20210604153325446"></p><h2 id="二、配置mysql">二、配置mysql</h2><h3 id="2-1-创建仓库">2.1 创建仓库</h3><p>在数据库实例上，以根用户身份登录数据库控制台：</p><pre class="line-numbers language-none"><code class="language-none">mysql -u root -p<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>根据提示输入密码。</p><ol start="3"><li><p>创建将由Gitea使用的数据库用户，并通过密码进行身份验证。本示例使用<code>'gitea'</code>密码。请为您的实例使用安全密码。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">USER</span> <span class="token string">'zjt'</span> IDENTIFIED <span class="token keyword">BY</span> <span class="token string">'xxxxxxxxx'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>适当替换上面的用户名和密码。</p></li><li><p>使用UTF-8字符集和排序规则创建数据库。确保使用<code>utf8mb4</code>charset代替，<code>utf8</code>因为前者支持<em>Basic Multilingual Plane</em>之外的所有Unicode字符（包括emoji表情）。另外，根据您的预期内容选择排序规则。如有疑问，请使用<code>unicode_ci</code>或<code>general_ci</code>。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">DATABASE</span> giteadb <span class="token keyword">CHARACTER</span> <span class="token keyword">SET</span> <span class="token string">'utf8mb4'</span> <span class="token keyword">COLLATE</span> <span class="token string">'utf8mb4_unicode_ci'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>适当替换数据库名称。</p></li><li><p>将数据库的所有特权授予上面创建的数据库用户。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">GRANT</span> <span class="token keyword">ALL</span> <span class="token keyword">PRIVILEGES</span> <span class="token keyword">ON</span> giteadb<span class="token punctuation">.</span><span class="token operator">*</span> <span class="token keyword">TO</span> <span class="token string">'zjt'</span><span class="token punctuation">;</span>FLUSH <span class="token keyword">PRIVILEGES</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>从数据库控制台退出<code>exit</code>。</p></li><li><p>在您的Gitea服务器上，测试与数据库的连接：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">mysql -u zjt -h 192.168.1.164 -p giteadb<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中，<code>gitea</code>是数据库用户名，<code>giteadb</code>是数据库名称和192.168.1.164是数据库实例的IP地址。省略<code>-h</code>本地数据库选项。</p><p>2.2您应该已连接到数据库。</p></li></ol><h3 id="2-2-链接gitea">2.2 链接gitea</h3><p>​1、进入192.168.1.164：10080//此处为gitea镜像的地址</p><p>​2、在此处设置数据库的名称、用户等</p><p>​3、设置好之后进入192.168.1.164:10080注册第一个用户。默认的第一个用户是管理员.</p><h2 id="三、git">三、git</h2><pre class="line-numbers language-none"><code class="language-none">sudo apt-get install git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="四、网络">四、网络</h2><h3 id="4-1-安装net—tools">4.1 安装net—tools</h3><pre class="line-numbers language-none"><code class="language-none">apt-get install net-tools<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="4-2内网穿透">4.2内网穿透</h3><h4 id="4-2-1-natapp">4.2.1 natapp</h4><p>官网下载客户端（<a href="https://natapp.cn/#download%EF%BC%89%EF%BC%8C%E9%9C%80%E8%A6%81%E6%B3%A8%E5%86%8C%E8%B4%A6%E5%8F%B7%EF%BC%8C%E8%B4%AD%E4%B9%B0%E9%9A%A7%E9%81%93%EF%BC%8C%E4%BC%9A%E5%BE%97%E5%88%B0%E4%B8%80%E4%B8%AAauthtoken%EF%BC%8C%E8%BF%9B%E5%85%A5%E5%88%B0%E4%B8%8B%E8%BD%BD%E7%9A%84%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%AD%E5%85%88%E7%99%BB%E5%BD%95%E4%B9%8B%E5%90%8E%EF%BC%9A">https://natapp.cn/#download），需要注册账号，购买隧道，会得到一个authtoken，进入到下载的客户端文件夹中先登录之后：</a></p><pre class="line-numbers language-none"><code class="language-none">nohup .&#x2F;natapp -authtoken&#x3D;xxxx -log&#x3D;stdout &amp;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="4-2-2-ngrok">4.2.2 ngrok</h4><p>arm服务器上安装客户端</p><p>运行：</p><pre class="line-numbers language-none"><code class="language-none">.&#x2F;ngrok authtoken &lt;your_auth_token&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="4-3访问IP白名单">4.3访问IP白名单</h3><p>配置/etc/hosts.allow文件和/etc/hosts.deny文件，前者设置可允许的ip，后面设置不允许的ip一般设置为前者为允许的ip。后者全部选择，如下：</p><table><thead><tr><th>允许内容</th><th>书写格式（改成自自需要的IP或IP段）</th></tr></thead><tbody><tr><td>ssh允许单个ip</td><td>sshd:192.168.220.1</td></tr><tr><td>ssh允许ip段</td><td>sshd:192.168.220.</td></tr><tr><td>telnet允许单个ip</td><td>in.telnetd:192.168.220.1</td></tr><tr><td>telnet允许ip段</td><td>in.telnetd:192.168.221.</td></tr></tbody></table><p>在/etc/hosts.deny中：</p><pre class="line-numbers language-none"><code class="language-none">sshd:ALLin.telnetd:ALL<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>执行：</p><pre class="line-numbers language-none"><code class="language-none">service ssh restartservice xinetd restart<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="4-4固定IP">4.4固定IP</h3><pre><code>$ cd /etc/netplan$ ls</code></pre><p>查看网络名称</p><pre class="line-numbers language-none"><code class="language-none">$ ifconfig$ vim xxxxxxxxxxx.yaml# Let NetworkManager manage all devices on this systemnetwork:  version: 2  renderer: NetworkManager  ethernets:     enp3s0: #配置的网卡名称,使用ifconfig -a查看得到       dhcp4: no #dhcp4关闭       addresses: [192.168.202.36&#x2F;24] #设置本机IP及掩码       gateway4: 192.168.202.1 #设置网关       nameservers:         addresses: [192.168.202.1] #设置DNS<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>更新命令：$ sudo netplan apply</p><h2 id="五、Anaconda">五、Anaconda</h2><h3 id="5-1安装">5.1安装</h3><p>​官网下载.sh文件，在想要安装的目录下运行：</p><pre class="line-numbers language-none"><code class="language-none">$ bash .&#x2F;path&#x2F;to&#x2F;anaconda&#x2F;AnacondaXXX.sh -p &#x2F;home&#x2F;i&#x2F;favorate&#x2F; -u<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​或者在安装的时候询问目录的时候手动选择目录。安装好之后不需要重启，命令行输入python显示：</p><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210519150359183.png" alt="image-20210519150359183"></p><p>或者执行：</p><pre class="line-numbers language-none"><code class="language-none">$ conda --version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>没有提示找不到conda命令即可。</p><h3 id="5-2添加环境">5.2添加环境</h3><p>​直接添加到系统环境，所有用户就都可以用，切换到root用户下：</p><pre class="line-numbers language-none"><code class="language-none">$ vim ~&#x2F;.bashrc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在最后一行添加：</p><pre class="line-numbers language-none"><code class="language-none">export PATH&#x3D;&quot;&#x2F;home&#x2F;xupp&#x2F;anaconda3&#x2F;bin:$PATH&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后执行命令 ：</p><pre class="line-numbers language-none"><code class="language-none">$ source  ~&#x2F;.bashrc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="5-3-创建环境">5.3 创建环境</h3><p>创建python版本为version的环境</p><pre class="line-numbers language-linux" data-language="linux"><code class="language-linux">conda create  -n your_env_name python &#x3D;(version)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装包</p><pre class="line-numbers language-none"><code class="language-none">conda install xxx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="六、nvidia环境">六、nvidia环境</h2><h2 id="七、数据库">七、数据库</h2><h3 id="7-1-创建">7.1 创建</h3><p>创建将由Gitea使用的数据库用户，并通过密码进行身份验证。本示例使用<code>'gitea'</code>密码。请为您的实例使用安全密码。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">USER</span> <span class="token string">'zjt'</span> IDENTIFIED <span class="token keyword">BY</span> <span class="token string">'xxxxxxxxx'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>适当替换上面的用户名和密码。</p><ol><li><p>使用UTF-8字符集和排序规则创建数据库。确保使用<code>utf8mb4</code>charset代替，<code>utf8</code>因为前者支持<em>Basic Multilingual Plane</em>之外的所有Unicode字符（包括emoji表情）。另外，根据您的预期内容选择排序规则。如有疑问，请使用<code>unicode_ci</code>或<code>general_ci</code>。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">DATABASE</span> giteadb <span class="token keyword">CHARACTER</span> <span class="token keyword">SET</span> <span class="token string">'utf8mb4'</span> <span class="token keyword">COLLATE</span> <span class="token string">'utf8mb4_unicode_ci'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>适当替换数据库名称。</p></li><li><p>将数据库的所有特权授予上面创建的数据库用户。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">GRANT</span> <span class="token keyword">ALL</span> <span class="token keyword">PRIVILEGES</span> <span class="token keyword">ON</span> giteadb<span class="token punctuation">.</span><span class="token operator">*</span> <span class="token keyword">TO</span> <span class="token string">'zjt'</span><span class="token punctuation">;</span>FLUSH <span class="token keyword">PRIVILEGES</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>从数据库控制台退出<code>exit</code>。</p></li></ol><h3 id="7-2-查询">7.2 查询</h3><p>进入数据库</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">mysql -u root -p#然后输入密码<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查询 所有用户以及密码信息</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">select user,host,authentication_string from user；#5.7版本之后没有password字段了<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>7.3</p><h2 id="八、用户管理">八、用户管理</h2><h3 id="8-1-docker镜像">8.1 docker镜像</h3><h3 id="8-2-容器创建">8.2 容器创建</h3><pre class="line-numbers language-docker" data-language="docker"><code class="language-docker">docker run -it --name="images-user0" --gpus 1  -p 192.168.1.164:local-port:22 images /bin/bash<span class="token comment">#docker run -it --name="cuda-QingDao2" --gpus '"device=2"' -v /home/lcm-data:/home/lcm-data -p 192.168.1.164:2474:22 nvidia/cuda:10.2-cudnn7-devel-ubuntu18.04 /bin/bash</span>sudo docker run -it --name="cuda-2080-zjt" --gpus=all -v /home/old-gitea/user-data/zjt:/home/data  --restart=always -p 192.168.1.164:1001:22 -p 192.168.1.164:2001:8000 nvidia/cuda:10.2-cudnn7-devel-ubuntu18.04 /bin/bash<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="8-3容器管理">8.3容器管理</h3><h4 id="8-3-1修改管理员密码：">8.3.1修改管理员密码：</h4><pre class="line-numbers language-linux" data-language="linux"><code class="language-linux">passwd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="8-3-2-创建删除用户">8.3.2 创建删除用户</h4><p>创建用户</p><pre class="line-numbers language-none"><code class="language-none">useradd  -d  &#x2F;wd&#x2F;user0   -m -s  &#x2F;bin&#x2F;bash -u uid user0passwd user0usermod -aG sudo  user0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>删除用户</p><pre class="line-numbers language-none"><code class="language-none">userdel -r username<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="8-3-3下载ssh服务端">8.3.3下载ssh服务端</h4><pre class="line-numbers language-none"><code class="language-none">apt-get updateapt-get install sudoapt-get install openssh-serverapt-get install vimservice ssh start#如果下载慢可以换源，执行：#vim &#x2F;etc&#x2F;apt&#x2F;source.list#添加清华源、阿里源#apt-get update &#x2F;etc&#x2F;init.d&#x2F;ssh start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>8.3.4 配置cuda环境</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">vim ~/.bashrc<span class="token keyword">export</span> PATH<span class="token operator">=</span>/usr/local/cuda-10.2/bin<span class="token punctuation">:</span><span class="token variable">$PATH</span><span class="token keyword">export</span> LD_LIBRARY_PATH<span class="token operator">=</span>/usr/local/cuda-10.2/lib64<span class="token punctuation">:</span><span class="token variable">$LD_LIBRARY_PATH</span>source ~/.bashrc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="8-4-容器端口内网穿透">8.4 容器端口内网穿透</h3><pre class="line-numbers language-none"><code class="language-none">vim &#x2F;home&#x2F;wzy&#x2F;docker&#x2F;frpc&#x2F;frpc.ini&#x2F;&#x2F;添加新的端口映射，local-port与上面相同docker restart frpc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>同时让师兄在宝塔面板打开local-port映射长度</p>]]></content>
    
    
    <summary type="html">服务器配置</summary>
    
    
    
    <category term="服务器" scheme="https://naughtyrabbit.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
    <category term="服务器" scheme="https://naughtyrabbit.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>利用pagemap获取虚拟地址对应物理地址</title>
    <link href="https://naughtyrabbit.github.io/2022/11/23/linux-pagemap/"/>
    <id>https://naughtyrabbit.github.io/2022/11/23/linux-pagemap/</id>
    <published>2022-11-23T03:08:51.000Z</published>
    <updated>2022-11-26T14:22:58.848Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>利用linux虚拟文件系统获取虚拟地址对应物理地址，同时，借由fork()机制和全局局部变量在虚拟内存中的位置分析写时拷贝技术。</p></blockquote><span id="more"></span><h3 id="一、pagemap相关知识">一、pagemap相关知识</h3><p> Linux文件目录中的/proc记录着当前进程的信息，称其为虚拟文件系统。在/proc下有一个链接目录名为self，这意味着哪一个进程打开了它，self中存储的信息就是所链接进程的。self中有一个名为pagemap的文件，专门用来记录所链接进程的物理页号信息。这样通过/proc/pid/pagemap文件，允许一个用户态的进程查看到每个虚拟页映射到的物理页。<br> /proc/pid/pagemap中的每一项都包含了一个64位的值，这个值内容如下所示。每一项的映射方式不同于真正的虚拟地址映射，其文件中遵循独立的对应关系，即虚拟地址相对于0x0经过的页面数是对应项在文件中的偏移量</p><pre class="line-numbers language-none"><code class="language-none">* &#x2F;proc&#x2F;pid&#x2F;pagemap.  This file lets a userspace process find out which   physical frame each virtual page is mapped to.  It contains one 64-bit   value for each virtual page, containing the following data (from   fs&#x2F;proc&#x2F;task_mmu.c, above pagemap_read):    * Bits 0-54  page frame number (PFN) if present&#x2F;&#x2F;present为1时，bit0-54表示物理页号    * Bits 0-4   swap type if swapped    * Bits 5-54  swap offset if swapped    * Bit  55    pte is soft-dirty (see Documentation&#x2F;vm&#x2F;soft-dirty.txt)    * Bit  56    page exclusively mapped (since 4.2)    * Bits 57-60 zero    * Bit  61    page is file-page or shared-anon (since 3.5)    * Bit  62    page swapped    * Bit  63    page present&#x2F;&#x2F;如果为1，表示当前物理页在内存中；为0，表示当前物理页不在内存中<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 根据上表，我们首先启动某个进程，获取该进程的进程号<strong>pid</strong>,然后打开/proc/pid/pagemap这个文件，读取其内容（这个文件比较大，正常在命令行中无法打开，因为每一个虚拟地址都有一条类似上表的记录）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*operating environment：Ubuntu 18.04.2 LTSgcc version 7.5.0程序功能：输入进程pid和虚拟地址，计算对应物理地址本程序提供自身pid号  一个全局变量a 和一个局部变量b ，可以输入本程序自身pid和相应虚拟地址进行查询也可以使用其他程序的pid和虚拟地址程序必须在root权限下运行，否则读取到的pagemap数据为全0*/</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdint.h></span></span><span class="token comment">//计算虚拟地址对应的地址，传入虚拟地址vaddr，通过paddr传出物理地址</span><span class="token keyword">int</span> <span class="token function">mem_addr</span><span class="token punctuation">(</span><span class="token class-name">pid_t</span> pid<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> vaddr<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token operator">*</span>paddr<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> pageSize <span class="token operator">=</span> <span class="token function">getpagesize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//调用此函数获取系统设定的页面大小，通常为4k</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> v_pageIndex <span class="token operator">=</span> vaddr <span class="token operator">/</span> pageSize<span class="token punctuation">;</span><span class="token comment">//计算此虚拟地址相对于0x0的经过的页面数</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> v_offset <span class="token operator">=</span> v_pageIndex <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token class-name">uint64_t</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//计算在/proc/pid/pagemap文件中的偏移量</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> page_offset <span class="token operator">=</span> vaddr <span class="token operator">%</span> pageSize<span class="token punctuation">;</span><span class="token comment">//计算虚拟地址在页面中的偏移量</span><span class="token class-name">uint64_t</span> item <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//存储对应项的pagemap值</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> total_page <span class="token operator">=</span> <span class="token number">64</span> <span class="token operator">*</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">;</span><span class="token keyword">int</span> present_page <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">char</span> path <span class="token punctuation">[</span><span class="token number">0x100</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token function">sprintf</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> <span class="token string">"/proc/%u/pagemap"</span><span class="token punctuation">,</span> pid<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//生成进程pid对应pagemap的路径</span><span class="token keyword">int</span> fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> O_RDONLY<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//以只读方式打开/proc/pid/pagemap</span><span class="token keyword">if</span><span class="token punctuation">(</span>fd <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//判断是否打开失败</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"open /proc/self/pagemap error\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">lseek</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> v_offset<span class="token punctuation">,</span> <span class="token constant">SEEK_SET</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//移动到pagemap相应的位置，即存储虚拟页对应的信息位置</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"lseek error\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">read</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>item<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token class-name">uint64_t</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token class-name">uint64_t</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//读取对应项的值，并存入item中，且判断读取数据位数是否正确</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"read item error\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">uint64_t</span><span class="token punctuation">)</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">63</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> item<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//判断present是否为0，即该页是否被换出内存</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"page present is 0\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">4</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token class-name">uint64_t</span> phy_pageIndex <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">uint64_t</span><span class="token punctuation">)</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">55</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> item<span class="token punctuation">;</span><span class="token comment">//计算物理页号，即取item的bit0-54</span><span class="token operator">*</span>paddr <span class="token operator">=</span> <span class="token punctuation">(</span>phy_pageIndex <span class="token operator">*</span> pageSize<span class="token punctuation">)</span> <span class="token operator">+</span> page_offset<span class="token punctuation">;</span><span class="token comment">//再加上页内偏移量就得到了物理地址</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"pid       virtual addr      v page index    page offset       pagemap item            phy page index      physical addr\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%-10d%-18lx%-16lx%-18lx%-24lx%-20lx%-20lx\n"</span><span class="token punctuation">,</span> pid<span class="token punctuation">,</span> vaddr<span class="token punctuation">,</span> v_pageIndex<span class="token punctuation">,</span> page_offset<span class="token punctuation">,</span> item<span class="token punctuation">,</span> phy_pageIndex<span class="token punctuation">,</span> <span class="token operator">*</span>paddr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// global variable a</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Please run in admin mode\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Use CTRL+C to exit\n\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// local variable a</span><span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"my pid = %d\nglobal var 'a' virtual addr = 0x%lx\nlocal var 'b' virtual addr = 0x%lx\n"</span><span class="token punctuation">,</span><span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>a<span class="token punctuation">,</span><span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">pid_t</span> pid <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//pid</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> vaddr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//虚拟地址</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> phy <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//物理地址</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\ninput the pid:         "</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>pid<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"input the vitual addr: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%lx"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>vaddr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">mem_addr</span><span class="token punctuation">(</span>pid<span class="token punctuation">,</span> vaddr<span class="token punctuation">,</span> <span class="token operator">&amp;</span>phy<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"v_addr to phy_addr failure\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 程序主要声明了一个全局变量和一个局部变量，用以返回出其虚拟地址以供在pagemap文件中查找（虚拟地址相当于数组下标，对应值即是pagemap项），然后如果该地址在物理地址中存在即present位1，0~53位即是该虚拟地址对应的物理页号，结合物理页号和虚拟地址的偏移量（低12位，即4k）即可得到虚拟地址对应的物理地址。</p><h3 id="二、文件读写函数">二、文件读写函数</h3><p> 为了找出该进程实际用了多少内存空间（实际在物理内存中存在），即上述pagemap单项中present值为<strong>1</strong>的项有多少。最容易想到的自然是遍历（下一节会解释该方法的不可行性，或者不建议这么做的原因）。<br> 在源代码中重新打开<strong>pagemap</strong>文件，循环遍历，初始化总项数为<strong>1024 * 1024</strong>（4g/4k，一共这么多个虚拟页表）。写出如下代码，该代码错误之处很多，下面解释。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> O_RDONLY<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//以只读方式打开/proc/pid/pagemap</span><span class="token keyword">if</span><span class="token punctuation">(</span>fd <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//判断是否打开失败</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"open /proc/self/pagemap error\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>total_page<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">lseek</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token class-name">uint64_t</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token constant">SEEK_SET</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//移动到pagemap相应的位置，即存储虚拟页对应的信息位置</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"lseek error\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">read</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>item<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token class-name">uint64_t</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token class-name">uint64_t</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//读取对应项的值，并存入item中，且判断读取数据位数是否正确</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"read item error\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">uint64_t</span><span class="token punctuation">)</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">63</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> item<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//判断present是否为0，即该页是否被换出内存</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"page present is 1, count++\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>present_page<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"left %d pages to read\n"</span><span class="token punctuation">,</span> total_page<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"current item %-24lx\n"</span><span class="token punctuation">,</span> item<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 首先是<strong>lseek</strong>函数,该函数用来调整当前文件读写位置，参数意义如下：</p><pre class="line-numbers language-none"><code class="language-none">fd：文件描述符offset：偏移量whence：位置       SEEK_SET：The offset is set to offset bytes. offset为0时表示文件开始位置。      SEEK_CUR：The offset is set to its current location plus offset bytes. offset为0时表示当前位置。      SEEK_END：The offset is set to the size of the file plus offset bytes. offset为0时表示结尾位置<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 因此上述代码错误主要在于第三个参数的设置，应该设为<strong>SEEK_CUR</strong>，每次从上次读的文件末去读。<br> 除此之外，<strong>read</strong>函数也会改变当前文件读写位置，因此如果上述代码只改<strong>lseek</strong>函数就相当于读一个<strong>item</strong>跳一个<strong>item</strong>。总结一下，如果想要连续读<strong>item</strong>，其实只需要一直使用<strong>read</strong>函数即可，每次调用<strong>read</strong>函数之后会自动将文件读写位置指向本次读的文件位置末。也因此在利用<strong>read</strong>，<strong>write</strong>函数进行读写操作时，如果先写入数据，然后立即读，此时是读不到写入数据的，因为读位置在上一次写位置的末位置，一般在读之前利用<strong>lseek</strong>函数调整当前文件读写位置至合适。</p><h3 id="三、64位机地址空间">三、64位机地址空间</h3><p> 解决完了一些函数使用上的错误后，重新执行代码，结果<strong>present</strong>的总虚拟页数还是0，继续找原因，稍微计算一下1024 x 1024的值明显比下图中虚拟页表值要小的多。<br><img src="https://m1.im5i.com/2022/11/24/U5pKqx.png" alt="虚拟页表"><br> 按4g虚拟内存来算，每个页表4k，应该是有1024 x 1024项，但是现在不匹配，在算一下4g的虚拟内存是 2^32 即32位，换算成16进制也是8位，而图中的虚拟地址却是48位。然后就想到了4g虚拟内存是对于32位机来说的，对于64位机，实际用了48位，也就是2^48寻址空间，也就是256T的虚拟内存空间，页表单位仍是4k，除下来2^48 / 2^12 = 36位，换算成16进制是9位，与图中相符。关于64位机的地址空间其实也不是都有用，详情可以查阅相关资料，这里不再深究。<br> 然后我们再算一下，2^36 = 1024 * 1024 * 1024 * 3，中间我跑了一下1024 * 1024 * 3的遍历，用了约18分钟。然后再乘上1024,大约需要几天才能遍历完，这也是之前提到的遍历这种策略不可行的原因（其实还可以根据/proc/pid/maps文件找出实际使用的地址空间，在其中遍历，能够大大缩小遍历范围，但是不再考虑，下面来看最终的实现方法）</p><h3 id="四、-proc-pid-status文件">四、/proc/pid/status文件</h3><p> status文件的意义如下</p><pre class="line-numbers language-none"><code class="language-none">&quot;VmPeak:\t%8lu kB\n&quot;------------------------------------虚拟内存使用量的峰值，取mm-&gt;total_vm和mm-&gt;hiwater_vm的大值。&quot;VmSize:\t%8lu kB\n&quot;------------------------------------当前虚拟内存的实际使用量。&quot;VmLck:\t%8lu kB\n&quot;-------------------------------------PG_mlocked属性的页面总量，常被mlock()置位。&quot;VmPin:\t%8lu kB\n&quot;-------------------------------------不可被移动的Pined Memory内存大小。&quot;VmHWM:\t%8lu kB\n&quot;-------------------------------------HWM是High Water Mark的意思，表示rss的峰值。&quot;VmRSS:\t%8lu kB\n&quot;-------------------------------------应用程序实际占用的物理内存大小，这里和VmSize有区别。VmRss要小于等于VmSize。&quot;RssAnon:\t%8lu kB\n&quot;-----------------------------------匿名RSS内存大小。&quot;RssFile:\t%8lu kB\n&quot;-----------------------------------文件RSS内存大小。&quot;RssShmem:\t%8lu kB\n&quot;----------------------------------共享内存RSS内存大小。&quot;VmData:\t%8lu kB\n&quot;------------------------------------程序数据段的所占虚拟内存大小，存放了初始化了的数据。&quot;VmStk:\t%8lu kB\n&quot;-------------------------------------进程在用户态的栈大小。&quot;VmExe:\t%8lu kB\n&quot;-------------------------------------进程主程序代码段内存使用量，即text段大小。&quot;VmLib:\t%8lu kB\n&quot;-------------------------------------进程共享库内存使用量。&quot;VmPTE:\t%8lu kB\n&quot;-------------------------------------进程页表项Page Table Entries内存使用量。&quot;VmPMD:\t%8lu kB\n&quot;-------------------------------------进程PMD内存使用量。&quot;VmSwap:\t%8lu kB\n&quot;,-----------------------------------进程swap使用量。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 下面程序实现对status文件的解析，打印输入pid程序的虚拟内存，实际物理内存占用：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">get_memory_by_pid</span><span class="token punctuation">(</span><span class="token class-name">pid_t</span> pid<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    FILE <span class="token operator">*</span>fd<span class="token punctuation">;</span>    <span class="token keyword">char</span> file<span class="token punctuation">[</span><span class="token number">64</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> line_buff<span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> name_VmRSS<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> name_VmSize<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> name_VmSwap<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span> VmRSS<span class="token punctuation">,</span> VmSize<span class="token punctuation">,</span> VmSwap <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token function">sprintf</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span> <span class="token string">"/proc/%d/status"</span><span class="token punctuation">,</span> pid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 以R读的方式打开文件再赋给指针fd</span>    fd <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>fd<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token comment">// 读取VmRSS这一行的数据</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">40</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">fgets</span><span class="token punctuation">(</span>line_buff<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>line_buff<span class="token punctuation">)</span><span class="token punctuation">,</span> fd<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"read error!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strstr</span><span class="token punctuation">(</span>line_buff<span class="token punctuation">,</span> <span class="token string">"VmRSS"</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token function">sscanf</span><span class="token punctuation">(</span>line_buff<span class="token punctuation">,</span> <span class="token string">"%s %d"</span><span class="token punctuation">,</span> name_VmRSS<span class="token punctuation">,</span> <span class="token operator">&amp;</span>VmRSS<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strstr</span><span class="token punctuation">(</span>line_buff<span class="token punctuation">,</span> <span class="token string">"VmSize"</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token function">sscanf</span><span class="token punctuation">(</span>line_buff<span class="token punctuation">,</span> <span class="token string">"%s %d"</span><span class="token punctuation">,</span> name_VmSize<span class="token punctuation">,</span> <span class="token operator">&amp;</span>VmSize<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strstr</span><span class="token punctuation">(</span>line_buff<span class="token punctuation">,</span> <span class="token string">"VmSwap"</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token function">sscanf</span><span class="token punctuation">(</span>line_buff<span class="token punctuation">,</span> <span class="token string">"%s %d"</span><span class="token punctuation">,</span> name_VmSwap<span class="token punctuation">,</span> <span class="token operator">&amp;</span>VmSwap<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"当前使用的物理内存：\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">fprintf</span> <span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"====%s： %d kB ====\n"</span><span class="token punctuation">,</span> name_VmRSS<span class="token punctuation">,</span> VmRSS<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"当前使用的虚拟内存：\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">fprintf</span> <span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"====%s： %d kB====\n"</span><span class="token punctuation">,</span> name_VmSize<span class="token punctuation">,</span> VmSize<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"进程swap使用量：\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">fprintf</span> <span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"====%s： %d kB====\n"</span><span class="token punctuation">,</span> name_VmSwap<span class="token punctuation">,</span> VmSwap<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">fclose</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参考：<a href="https://blog.csdn.net/kongkongkkk/article/details/74366200">https://blog.csdn.net/kongkongkkk/article/details/74366200</a></p>]]></content>
    
    
    <summary type="html">利用linux虚拟文件系统获取虚拟地址对应物理地址，同时，借由fork()机制和全局局部变量在虚拟内存中的位置分析写时拷贝技术。</summary>
    
    
    
    <category term="linux" scheme="https://naughtyrabbit.github.io/categories/linux/"/>
    
    
    <category term="fork()" scheme="https://naughtyrabbit.github.io/tags/fork/"/>
    
    <category term="pagemap" scheme="https://naughtyrabbit.github.io/tags/pagemap/"/>
    
  </entry>
  
  <entry>
    <title>个人随笔-意识流日记-2022.11.6</title>
    <link href="https://naughtyrabbit.github.io/2022/11/06/private-diary-1/"/>
    <id>https://naughtyrabbit.github.io/2022/11/06/private-diary-1/</id>
    <published>2022-11-06T11:49:08.000Z</published>
    <updated>2023-06-09T14:51:05.112Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>私人内容，请自重</p></blockquote><span id="more"></span> <p><font face="楷体" color="SteelBlue" size="4"> <p><strong> 日记的话，就不用想标题了吧。。。</strong><br><strong> 为什么想起写东西记录了呢，大抵是两个原因罢。一是昨天和一个朋友语音，我想起来我买的夹心饼干，问他喜欢吃甜食不，他说喜欢，我就让他把他地址给我，我买了给他寄去。他又反过来问我的地址，问我生日几号。我向来是不正经过生日的，一个是嫌麻烦，二是我本人没有太浓的社交欲望，感觉“过生日”这种事，emmm，不太适合我。然后朋友说人和人之前也就是靠这种所谓特殊的日子联系到一起，也是一种仪式感吧。</strong><br><strong> 关于仪式感，其实我还比较赞同，也是受我本科大三的英语老师影响吧，当时疫情原因在上网课，在家穿着睡衣坐在电脑面前听课，老师就说我猜你们现在还靠在床上，甚至还有人躺在床上在上课吧，生活要有点仪式感啊，孩子们。说到“孩子们”，我本科期间有三位英语老师，对学生的称呼都是“孩子们”，个人也挺喜欢这种叫法，也把这种叫法带到我自己的生活中，喊实验室的朋友吃饭也是喊一句“吃饭吗，孩-子-们”</strong><br><strong> 说回仪式感，其实本身没有所谓“一定”的意义，但人生一场，也不是所有事都要有意义，世间本没有那么多理由。我觉得人本身的存在也是，来到世间，与一部分人产生羁绊，创造回忆，回忆回忆，感叹回忆，最终活在回忆中。当然如果没有很大的影响，让全世界知道，能活在身边人的回忆中也是极好的。这便是起笔原因之一，为了“仪式感”，为了记录，在时间长河中，给自己的人生稍微印深一些，哪怕是只对自己来说，也不至于日后回忆起来，自己的过往一片空白，也是一种悲哀罢</strong><br><strong> 第二个原因就比较私人了吧，文前就说了这是私人内容，以防万一，这里再重申一次，如果你觉得你足够想了解我，那和我一起继续看下去罢。</strong><br><strong> 最后说一句，愿我们别太早醒来了，哭笑着，把短暂的梦做到末。方寸人间，风雨如晦，谢谢你来过。</strong><br></font></p><br><img src="https://s.im5i.com/2021/05/21/S0qUp.jpg" alt="好康的壁纸"></p>]]></content>
    
    
    <summary type="html">私人内容，请自重</summary>
    
    
    
    <category term="私人日记" scheme="https://naughtyrabbit.github.io/categories/%E7%A7%81%E4%BA%BA%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="私人日记" scheme="https://naughtyrabbit.github.io/tags/%E7%A7%81%E4%BA%BA%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>用fork,exec,wait实现一个自己的shell</title>
    <link href="https://naughtyrabbit.github.io/2022/11/02/linux-myshell/"/>
    <id>https://naughtyrabbit.github.io/2022/11/02/linux-myshell/</id>
    <published>2022-11-02T01:06:35.000Z</published>
    <updated>2022-11-02T03:06:53.831Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>记录一下编写linux内核课程中遇到的问题和解决过程。</p></blockquote><span id="more"></span><h3 id="一、程序出不去？">一、程序出不去？</h3><p> 先看程序</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// myshell.c</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token comment">// used by exit</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token comment">// used by func fork,execlp,wait</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;wait.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// 记录子进程结束状态</span>    <span class="token keyword">int</span> status_c<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token class-name">pid_t</span> pid_c<span class="token punctuation">,</span> pid_cid<span class="token punctuation">;</span>        <span class="token comment">// 创建子进程</span>    pid_c <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 判断fork调用结果</span>        <span class="token comment">// 出错</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pid_c <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Error when fork called\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 子进程 处理命令行传入参数</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>pid_c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>               <span class="token comment">// 接受命令行传入参数，存入字符串</span>            <span class="token keyword">char</span> cmd_get<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment">// 模拟当前用户</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"h_zeng@ubuntu:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 读取传入命令</span>            <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> cmd_get<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span>cmd_get<span class="token punctuation">,</span> <span class="token string">"exit"</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"exit my shell\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">//printf("pid when child process : %d\n", getpid());</span>            <span class="token comment">// 处理echo命令</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span>cmd_get<span class="token punctuation">,</span> <span class="token string">"echo"</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> cmd_get<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// execl执行失败，返回</span>                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">execl</span><span class="token punctuation">(</span><span class="token string">"/bin/echo"</span><span class="token punctuation">,</span><span class="token string">"echo"</span><span class="token punctuation">,</span>cmd_get<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>                <span class="token punctuation">&#123;</span>                    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Error when execl called\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// 其余情况自动从环境变量“$PATH”所指出的路径中进行查找</span>            <span class="token comment">// execlp执行失败，返回</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">execlp</span><span class="token punctuation">(</span>cmd_get<span class="token punctuation">,</span> cmd_get<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>             <span class="token punctuation">&#123;</span>                <span class="token comment">//printf("cmd_get : %s\n", cmd_get);</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Error when execlp called\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>            <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 父进程 等待子进程结束</span>        <span class="token keyword">else</span>        <span class="token punctuation">&#123;</span>               <span class="token comment">// 等待子程序返回</span>            pid_cid <span class="token operator">=</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>status_c<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//printf("pid when wait : %d\n", getpid());</span>            <span class="token comment">// wait调用失败</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>pid_cid <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Error when wait called\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// wait调用成功</span>            <span class="token comment">// 子程序非正常结束返回，结束shell </span>            <span class="token comment">//printf("pid from wait(aka ended child process pid) : %d\n", pid_cid);</span>            <span class="token comment">//printf("status_c : %d\n", WEXITSTATUS(status_c));</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>status_c <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>             <span class="token punctuation">&#123;</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Exception occurs when child process end\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 编译运行，得到如图结果，普通的命令包括<strong>echo</strong>等都能正常完成，但是到<strong>exit</strong>的时候程序执行完了可以看到开头仍是我程序里写的模拟用户。<br><img src="https://m1.im5i.com/2022/11/02/UVBDrz.png" alt="程序出不去"><br> 回到程序，分析一波，emmm，啥都没分析出来，参考网上的类似程序实现，发现他把第一个命令行传入参数的接收操作放在了fork之前。嗯，在产生子程序之前判断了读入<strong>exit</strong>,然后结束整个程序，应该可行。改代码！</p><h3 id="二、多出来的子程序？">二、多出来的子程序？</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// myshell.c</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// 记录子进程结束状态</span>    <span class="token keyword">int</span> status_c<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token class-name">pid_t</span> pid_c<span class="token punctuation">,</span> pid_cid<span class="token punctuation">;</span>        <span class="token comment">// 接受命令行传入参数，存入字符串</span>        <span class="token keyword">char</span> cmd_get<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">// 模拟当前用户</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"h_zeng@ubuntu:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 读取传入命令</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> cmd_get<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span>cmd_get<span class="token punctuation">,</span> <span class="token string">"exit"</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"exit my shell\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 创建子进程</span>    pid_c <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 判断fork调用结果</span>        <span class="token comment">// 出错</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pid_c <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Error when fork called\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 子进程 处理命令行传入参数</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>pid_c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>               <span class="token comment">//printf("pid when child process : %d\n", getpid());</span>            <span class="token comment">// 处理echo命令</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span>cmd_get<span class="token punctuation">,</span> <span class="token string">"echo"</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> cmd_get<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// execl执行失败，返回</span>                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">execl</span><span class="token punctuation">(</span><span class="token string">"/bin/echo"</span><span class="token punctuation">,</span><span class="token string">"echo"</span><span class="token punctuation">,</span>cmd_get<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>                <span class="token punctuation">&#123;</span>                    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Error when execl called\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// 其余情况自动从环境变量“$PATH”所指出的路径中进行查找</span>            <span class="token comment">// execlp执行失败，返回</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">execlp</span><span class="token punctuation">(</span>cmd_get<span class="token punctuation">,</span> cmd_get<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>             <span class="token punctuation">&#123;</span>                <span class="token comment">//printf("cmd_get : %s\n", cmd_get);</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Error when execlp called\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>            <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 父进程 等待子进程结束</span>        <span class="token keyword">else</span>        <span class="token punctuation">&#123;</span>               <span class="token comment">// 等待子程序返回</span>            pid_cid <span class="token operator">=</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>status_c<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//printf("pid when wait : %d\n", getpid());</span>            <span class="token comment">// wait调用失败</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>pid_cid <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Error when wait called\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// wait调用成功</span>            <span class="token comment">// 子程序非正常结束返回，结束shell </span>            <span class="token comment">//printf("pid from wait(aka ended child process pid) : %d\n", pid_cid);</span>            <span class="token comment">//printf("status_c : %d\n", WEXITSTATUS(status_c));</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>status_c <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>             <span class="token punctuation">&#123;</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Exception occurs when child process end\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 再次编译运行，得到如图结果，<strong>exit</strong>能正常推出了，但是到<strong>echo</strong>的时候，正常打印出<em>hi</em>之后，<strong>execlp</strong>函数出现了错误，并且下面一行打印了两次模拟用户信息。<br><img src="https://m1.im5i.com/2022/11/02/UVBUzs.png" alt="多出来的子程序"><br> 回到程序，分析一波，很容易猜到程序比预想的“分裂”了多一次，导致把第二次读入的<em>hi</em>当成命令传入给<strong>execlp</strong>函数，但是突然发现一个问题，<strong>execlp</strong>函数出错后，子进程返回异常，父进程接收到异常应该结束掉整个shell程序，但是实际并没有。于是再次改代码，加上一些<strong>printf</strong>打印pid等信息看看猜想正确与否，以及为什么程序没有因为异常结束。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// myshell.c</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// 记录子进程结束状态</span>    <span class="token keyword">int</span> status_c<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token class-name">pid_t</span> pid_c<span class="token punctuation">,</span> pid_cid<span class="token punctuation">;</span>        <span class="token comment">// 接受命令行传入参数，存入字符串</span>        <span class="token keyword">char</span> cmd_get<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">// 模拟当前用户</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"h_zeng@ubuntu:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 读取传入命令</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> cmd_get<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span>cmd_get<span class="token punctuation">,</span> <span class="token string">"exit"</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"exit my shell\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 创建子进程</span>    pid_c <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 判断fork调用结果</span>        <span class="token comment">// 出错</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pid_c <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Error when fork called\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 子进程 处理命令行传入参数</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>pid_c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>               <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"pid when child process : %d\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 处理echo命令</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span>cmd_get<span class="token punctuation">,</span> <span class="token string">"echo"</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> cmd_get<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// execl执行失败，返回</span>                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">execl</span><span class="token punctuation">(</span><span class="token string">"/bin/echo"</span><span class="token punctuation">,</span><span class="token string">"echo"</span><span class="token punctuation">,</span>cmd_get<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>                <span class="token punctuation">&#123;</span>                    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Error when execl called\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// 其余情况自动从环境变量“$PATH”所指出的路径中进行查找</span>            <span class="token comment">// execlp执行失败，返回</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">execlp</span><span class="token punctuation">(</span>cmd_get<span class="token punctuation">,</span> cmd_get<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>             <span class="token punctuation">&#123;</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"cmd_get : %s\n"</span><span class="token punctuation">,</span> cmd_get<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Error when execlp called\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>            <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 父进程 等待子进程结束</span>        <span class="token keyword">else</span>        <span class="token punctuation">&#123;</span>               <span class="token comment">// 等待子程序返回</span>            pid_cid <span class="token operator">=</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>status_c<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"pid when wait : %d\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// wait调用失败</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>pid_cid <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Error when wait called\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// wait调用成功</span>            <span class="token comment">// 子程序非正常结束返回，结束shell </span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"pid from wait(aka ended child process pid) : %d\n"</span><span class="token punctuation">,</span> pid_cid<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// printf("status_c : %d\n", WEXITSTATUS(status_c));</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"status_c : %d\n"</span><span class="token punctuation">,</span> status_c<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>status_c <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>             <span class="token punctuation">&#123;</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Exception occurs when child process end\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 编译运行，得到如图结果，可以看到确实在用户输入<strong>echo hi</strong>之后有两个子程序执行了，第一个子进程正常结束，pid被父进程的<strong>wait</strong>函数捕获，值也一致，第二个子进程接收到了错误了<em>hi</em>为命令行输入，抛出<strong>execlp</strong>函数错误。然后--------------！<strong>wait</strong>函数得到的子进程返回状态居然是<strong>65280</strong>！！<br><img src="https://m1.im5i.com/2022/11/02/UVBdoo.png" alt="多出来的子程序"></p><h3 id="三、wait函数status">三、wait函数status</h3><p> 好了，知道第一次为什么程序结束不了了，父进程在子进程异常结束后，<strong>wait</strong>函数得到的子进程结束状态并不是想当然的 -1。 随即查阅了<strong>wait</strong>函数<strong>status</strong>参数的意义，发现要用<strong>WEXITSTATUS</strong>等宏来解析。重新编写程序。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// myshell.c</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// 记录子进程结束状态</span>    <span class="token keyword">int</span> status_c<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token class-name">pid_t</span> pid_c<span class="token punctuation">,</span> pid_cid<span class="token punctuation">;</span>        <span class="token comment">// 创建子进程</span>    pid_c <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 判断fork调用结果</span>        <span class="token comment">// 出错</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pid_c <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Error when fork called\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 子进程 处理命令行传入参数</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>pid_c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>               <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"pid when child process : %d\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 接受命令行传入参数，存入字符串</span>            <span class="token keyword">char</span> cmd_get<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment">// 模拟当前用户</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"h_zeng@ubuntu:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 读取传入命令</span>            <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> cmd_get<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span>cmd_get<span class="token punctuation">,</span> <span class="token string">"exit"</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"exit my shell\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// 处理echo命令</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span>cmd_get<span class="token punctuation">,</span> <span class="token string">"echo"</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> cmd_get<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// execl执行失败，返回</span>                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">execl</span><span class="token punctuation">(</span><span class="token string">"/bin/echo"</span><span class="token punctuation">,</span><span class="token string">"echo"</span><span class="token punctuation">,</span>cmd_get<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>                <span class="token punctuation">&#123;</span>                    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Error when execl called\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// 其余情况自动从环境变量“$PATH”所指出的路径中进行查找</span>            <span class="token comment">// execlp执行失败，返回</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">execlp</span><span class="token punctuation">(</span>cmd_get<span class="token punctuation">,</span> cmd_get<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>             <span class="token punctuation">&#123;</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"cmd_get : %s\n"</span><span class="token punctuation">,</span> cmd_get<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Error when execlp called\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>            <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 父进程 等待子进程结束</span>        <span class="token keyword">else</span>        <span class="token punctuation">&#123;</span>               <span class="token comment">// 等待子程序返回</span>            pid_cid <span class="token operator">=</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>status_c<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"pid when wait : %d\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// wait调用失败</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>pid_cid <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Error when wait called\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// wait调用成功</span>            <span class="token comment">// 子程序非正常结束返回，结束shell </span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"pid from wait(aka ended child process pid) : %d\n"</span><span class="token punctuation">,</span> pid_cid<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"status_c : %d\n"</span><span class="token punctuation">,</span> <span class="token function">WEXITSTATUS</span><span class="token punctuation">(</span>status_c<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">WEXITSTATUS</span><span class="token punctuation">(</span>status_c<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token function">WEXITSTATUS</span><span class="token punctuation">(</span>status_c<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">)</span>             <span class="token punctuation">&#123;</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Exception occurs when child process end\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">WEXITSTATUS</span><span class="token punctuation">(</span>status_c<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>             <span class="token punctuation">&#123;</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"the shell ended cause you typed 'exit' \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 编译运行，得到如图结果，程序可以正常运行，<strong>WEXITSTATUS</strong>宏可以将子进程结束状态与子程序<strong>exit</strong>中整型变量对应。</p><blockquote><p>注意：如果exit(-1)，那么解析出来的是255，但是其他机器上我不知道，保险起见把除0/1以外的返回视为异常。</p></blockquote><p><img src="https://m1.im5i.com/2022/11/02/UVBjtM.png" alt="多出来的子程序"></p><h3 id="四、总结">四、总结</h3><p> 程序整体思路是利用fork产生子进程，处理命令行输入参数的处理，然后结束子进程，父进程得到子进程返回状态，判断整体程序是否应该继续执行</p>]]></content>
    
    
    <summary type="html">记录一下编写linux内核课程中遇到的问题和解决过程</summary>
    
    
    
    <category term="linux" scheme="https://naughtyrabbit.github.io/categories/linux/"/>
    
    
    <category term="fork()" scheme="https://naughtyrabbit.github.io/tags/fork/"/>
    
    <category term="exec()" scheme="https://naughtyrabbit.github.io/tags/exec/"/>
    
    <category term="wait()" scheme="https://naughtyrabbit.github.io/tags/wait/"/>
    
  </entry>
  
  <entry>
    <title>FPGA_软错误缓解_介绍</title>
    <link href="https://naughtyrabbit.github.io/2022/08/24/FPGA-SEM-intro/"/>
    <id>https://naughtyrabbit.github.io/2022/08/24/FPGA-SEM-intro/</id>
    <published>2022-08-24T08:51:07.000Z</published>
    <updated>2022-11-23T03:07:50.399Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本篇主要是FPGA中软错误缓解相关知识入门介绍</p></blockquote><span id="more"></span><h3 id="综观">综观</h3><p> LogiCORE™ IP UltraScale™ 架构软错误缓解 (SEM) 控制器是一种自动配置、预先验证的解决方案，用于检测和纠正 Xilinx FPGA 配置存储器中的软错误。软错误是由电离辐射引起的状态元素中存储的值的意外变化。<br> SEM 控制器不能防止软错误；但是，它提供了一种更好地管理软错误的系统级影响的方法。对这些事件进行适当管理可以提高可靠性和可用性，并降低系统维护和停机成本。</p><p> 电离辐射能够在大多数硅器件中引起不希望的影响。从广义上讲，由单个事件引起的不良影响称为单一事件效应 <strong>single event effect</strong> (SEE)。在大多数情况下，这些事件不会永久损坏硅器件；不会对设备造成永久性损坏的 SEE 称为软错误。然而，软错误有可能降低可靠性。<br> Xilinx® 器件设计为对软错误具有固有的低敏感性。然而，赛灵思也认识到软错误在商业和实际限制范围内是不可避免的。因此，Xilinx 已将软错误检测和纠正功能集成到许多器件系列中。<br> 在许多应用中，可以忽略软错误。在需要更高可靠性的应用中，UltraScale™ 架构 SEM 控制器可以确保更高级别的可靠性。<br> 如果您的应用受益于使用 SEM 控制器，IP Design Checklist in<br>Appendix F 提供了使用和集成 SEM 控制器时的指导和注意事项列表。</p><h3 id="一、内存类型">一、内存类型</h3><p> 如果发生软错误，则会损坏一个或多个内存位。受影响的内存位可能在设备配置内存中（它决定了设计的行为），或者可能在设计内存元素中（它决定了设计的状态）。以下四个内存类别代表了设备中的大部分内存：</p><ul><li>配置内存——用于配置加载到设备中的设计功能的存储元素。这包括功能块行为和功能块连接。该内存在物理上分布在整个设备上，代表了最大的位数。只有一小部分位对于加载到设备中的任何特定设计的正确操作是必不可少的。</li><li>块存储器——用于存储设计状态的大容量存储元件。顾名思义，这些位被聚集成一个物理块，几个块分布在整个设备上。块存储器代表第二大位数。</li><li>分布式内存——用于存储设计状态的中等容量存储元件。这种类型的存储器存在于某些可配置逻辑块 (CLB) 中，并分布在整个设备中。分布式内存代表第三大位数。</li><li>触发器——用于存储设计状态的低容量存储元件。这种类型的存储器存在于所有可配置逻辑块 (CLB) 中，并且分布在整个设备中。触发器代表第四大位数。</li></ul><p> 极少数额外的内存位作为内部设备控制寄存器和状态元素存在。在这些区域中发生的软错误可能会导致区域或设备范围的干扰，称为单事件功能中断 (SEFI)。由于这些内存位的数量很少，SEFI 事件的频率在此讨论中被认为可以忽略不计，并且这些不常见的事件没有被 SEM 控制器处理。</p><h3 id="二、缓解方法">二、缓解方法</h3><p> 块存储器、分布式存储器和触发器中的设计状态的软错误缓解可以在设计本身中执行，方法是应用错误检测和纠正码或冗余等标准技术。未使用的设计状态资源（实际存在于器件中，但设计未使用）中的软错误将被忽略。关注可靠性的设计人员必须评估设计中的风险区域，并根据需要结合设计状态的缓解技术。<br> 配置存储器中设计功能的软错误缓解是使用错误检测和纠正代码执行的。<br> 配置存储器被组织成一个帧数组，很像一个宽的静态 RAM。在许多器件系列中，每个帧都受 ECC 保护，而在所有器件系列中，整个帧阵列都受 CRC 保护。这两种技术是互补的； CRC 对于错误检测非常强大，而 ECC 提供了高分辨率的错误位置。<br> SEM 控制器通过添加可选功能来将配置内存错误分类为“必要”或“非必要”，从而建立在集成逻辑的强大功能之上。这利用了这样一个事实，即只有一小部分配置存储器位对于任何特定设计的正确操作都是必不可少的。<br> 如果没有错误分类，所有配置内存错误都必须被认为是“必要的”。通过错误分类，大多数错误将被评估为“非必要”，从而消除误报并降低需要潜在破坏性系统级缓解响应的错误频率。<br> 此外，SEM 控制器扩展了内置校正功能以加速错误检测，并提供处理多位错误的可选功能。</p><h3 id="三、可靠性估计">三、可靠性估计</h3><p> 作为起点，系统可靠性规范应突出系统设计的关键部分，并为每个子部分所需的可靠性提供一个值。可靠性要求通常表示为及时失效 (FIT)，即在 10<sup>9</sup>小时（约 114,155 年）内预期的设计失效数量。<br> 当部署多个设计实例时，软错误影响其中任何一个实例的概率会成比例增加。例如，如果设计以 1,000 个产品单位装载，则所有已部署单位的标称 FIT 是 1,000 倍。这是一个重要的考虑因素，因为总部署的标称 FIT 可能会变得很大，并且可能代表服务或维护负担。<br> 总部署的标称 FIT 与单个单元受到影响的概率不同。此外，特定单元发生第二次软错误的概率取决于单个设计的 FIT，而不是部署。在为应用评估合适的软错误缓解策略时，这是一个重要的考虑因素。<br> 与软错误相关的 FIT 不得与产品预期寿命相混淆，后者考虑了系统某些部分的更换或物理修复。<br> Xilinx 器件 FIT 数据在 Xilinx 器件可靠性报告 (UG116) [参照 1] 中报告。数据揭示了软错误的总体频率。<br> 由于触发器的 FIT 非常低且数量少，触发器对 FIT 的贡献可以忽略不计。然而，这并没有贬低保护存储在触发器中的设计状态的重要性。如果存储在触发器中的任何状态对设计操作非常重要，则设计必须包含以适合应用的方式检测、纠正和恢复软错误的逻辑。<br> 在这些资源被高度利用的设计中，分布式内存和块内存对 FIT 的贡献可能很大。如前所述，通过在设计中使用软错误缓解技术可以显着降低 FIT 的贡献。例如，块存储器资源包括可用于某些块存储器配置的内置错误检测和纠正电路。对于所有块存储器和分布式存储器配置，可以使用可编程逻辑资源应用软错误缓解技术。<br> 配置内存对 FIT 的贡献很大。在不使用错误分类技术的情况下，配置内存中的所有软错误都必须被认为是“必要的”，因此对 FIT 的贡献超过了所有其他来源的总和。<br> 错误分类的使用不再将大多数软错误视为故障，从而减少了对 FIT 的贡献；如果软错误没有影响，则可以在没有任何中断的情况下对其进行纠正。<br> 在需要最高级别可靠性的设计中，配置存储器中的软错误分类至关重要。此功能由 SEM 控制器提供。</p><h3 id="四、功能摘要">四、功能摘要</h3><p> SEM 控制器可以根据设计要求以六种不同的模式生成：</p><ul><li>缓解和测试</li><li>仅缓解</li><li>检测和测试</li><li>仅检测</li><li>模拟</li><li>仅监控</li></ul><p> 缓解模式，缓解和测试以及仅缓解，启用错误检测，纠错和错误分类（可选）功能。错误注入在仅缓解模式中不可用。<br> 接下来的两种模式，Detect 和 Testing and Detect only，启用错误检测，但无法纠正或分类。错误注入在仅检测模式下不可用。<br> 最后两种模式（仅限仿真和监控）使您能够使用 SEM 控制器在发生单事件翻转 (SEU) 事件时评估和监控系统行为，而无需启用错误检测、错误纠正和错误分类功能。错误注入在仅监控模式下不可用。</p><h3 id="五、应用">五、应用</h3><p> 尽管 SEM 控制器可以自主运行，但大多数应用程序将该解决方案与应用程序级监控功能结合使用。此监控功能监控来自 SEM 控制器的事件报告，并确定是否需要执行其他操作（例如，重新配置设备或重置应用程序）。<br> 鼓励系统设计人员仔细考虑每个设计可靠性要求和系统级监督功能，以做出明智的决定。<br> 甚至需要一个错误缓解解决方案吗？如果需要 SEM 控制器，应该使用哪些功能？<br> 当 SEM 控制器是应用的最佳选择时，Xilinx 建议使用提供的 SEM 控制器，包括用于与外部设备连接的系统级设计帮助程序块。但是，如果应用程序需要，可以修改这些接口。</p><h3 id="六、SEM-IP-采用的主要考虑因素">六、SEM IP 采用的主要考虑因素</h3><p> 本节旨在评估 SEM IP 是否有助于满足产品部署的软错误缓解目标以及应选择哪种缓解方法。本节中使用的概念已在前面的部分中介绍过。<br> 有两个主要考虑因素：</p><ul><li>了解设计的软错误缓解要求</li><li>如果发生软错误，需要采取哪些措施</li></ul><ol><li><p>了解设计的软错误缓解要求<br> 如果软错误的影响对您的产品部署来说是一个问题，那么系统设计中的每个组件通常都需要一个 FIT 预算。要计算 Xilinx FPGA 的 FIT，请使用 SEU 休息室中提供的 SEU FIT 速率估计器，并查看 XAPP472 SEU 估计器以了解如何使用 FIT 速率估计器。<br> 要计算部署的 FIT，您至少需要：</p><ul><li>目标设备</li><li>要部署的设备的估计数量</li></ul><p> 除了为设备提供估计的 FIT 外，估计器还预测给定时间范围内预期的软错误数量。<br> 通过使用实施的设计，可以更准确地估计 FIT。这可以通过输入所使用的 Block RAM 数量、是否使用 Block RAM ECC 功能来检测和纠正软错误以及设计中基本位的百分比来实现。基本位定义为配置 RAM 位，用于定义 FPGA 上的功能。如果软错误无意中更改了一个基本位，则 FPGA 中的功能可能无法按预期运行。<br> 另一方面，如果更改了非必要位，则对功能没有影响。以下步骤确定设计中基本位的百分比：</p><ol><li>在 Vivado 中设置以下属性：</li></ol> <pre class="line-numbers language-none"><code class="language-none">set_property bitstream.seu.essentialbits yes [current_design]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>为您的设计重新生成比特流。</li><li>基本位百分比在 Vivado Tcl 控制台中打印，因此在生成位流和基本位数据时 Vivado 日志中打印。这是一个例子：</li></ol> <pre class="line-numbers language-none"><code class="language-none">Writing bitstream .&#x2F;sem_ultrap_v3_1_example.bit...Creating bitstream...Writing bitstream .&#x2F;sem_ultrap_v3_1_example.ebc...Creating essential bits data...This design has 707717 essential bits out of 143015456 total (0.49%).<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 完成 FIT 估计后，必须检查以确定是否满足部署的 FIT 要求。可能需要实施其他设计方法来降低 FIT。<br> 如果没有 FIT 目标，则不清楚需要进行哪些设计更改（以及随之而来的权衡）以减轻软错误影响，包括部署是否受益于使用 SEM IP。如果是这种情况，重要的是在集成之前确定使用 SEM IP 获得的好处。</p></li><li><p>发生软错误时要考虑的操作<br> SEM IP 可以配置为检测或检测和纠正软错误。因此，必须考虑对软错误做出反应的系统级操作（如果有的话）。如果在设计中检测到软错误时未采取任何措施，则应评估和理解在设计中使用 SEM IP 的好处。虽然这是一个有效的用例，但应该知道软错误对设计的影响，并且应该很好地理解这种缓解方法，以确保它满足软错误缓解目标。</p><blockquote><p>推荐！ 在设计中使用 SEM IP 时，强烈建议记录 Monitor 接口的输出。</p></blockquote><p> 图 1-1 显示了一个决策树示例，该示例迭代了系统在发生软错误时可以执行的操作。通过了解可能性和系统级考虑因素，可以决定是否在设计中使用 SEM IP。</p><blockquote><p>注意：此图仅作为示例提供，并未列出所有可能的注意事项。</p></blockquote><p><img src="https://m1.im5i.com/2022/08/29/Uqgths.png" alt="好康的壁纸"></p></li></ol><p>参考：PG187</p>]]></content>
    
    
    <summary type="html">本篇主要是FPGA中软错误缓解相关知识入门介绍</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>FPGA_动态功能切换_DFX RTL工程流程</title>
    <link href="https://naughtyrabbit.github.io/2022/08/23/FPGA-DFX-RTLprj/"/>
    <id>https://naughtyrabbit.github.io/2022/08/23/FPGA-DFX-RTLprj/</id>
    <published>2022-08-23T01:37:15.000Z</published>
    <updated>2022-08-23T13:59:48.180Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>接上一篇UltraScale DFX流程，本篇为RTL project流程</p></blockquote><span id="more"></span>  <p> 需要注意的是例程面向</p><ul><li>KCU116 (Kintex® UltraScale+™)</li><li>VCU118 (Virtex® UltraScale+™)</li><li>KCU105 (Kintex UltraScale)</li><li>VCU108 (Virtex UltraScale)</li><li>KC705 (Kintex-7)</li><li>VC707 (Virtex-7)</li><li>VC709 (Virtex-7)<br>这几块开发板，跑完之后看看能不能改到手上的板子。</li></ul><h3 id="一、解压例程">一、解压例程</h3><p> 根据ug947文档提示在赛灵思官网下载例程压缩包，解压定位到 <strong>\dfx_project</strong> 文件夹。</p><h3 id="二、加载初始源设计">二、加载初始源设计</h3><p> 任何 DFX 设计流程（基于项目或其他）的第一个唯一步骤是定义将被标记为可重新配置的设计部分。这是通过项目模式下分层源视图中的上下文菜单完成的。这些步骤将通过在简单设计中定义分区来完成初始项目创建。</p><ol><li><p>从档案中提取设计。 dfx_project 数据目录在本教程中称为 &lt;Extract_Dir&gt;。</p></li><li><p>打开 Vivado® IDE 并选择 Create Project，然后单击 Next。</p></li><li><p>选择 &lt;Extract_Dir&gt; 作为项目位置。将项目名称保留为 project_1，并选中创建项目子目录选项。点击下一步。</p></li><li><p>选择 RTL 项目并确保此时不指定源复选框未选中，然后单击下一步。</p></li><li><p>单击 Add Directories 按钮并选择要添加到设计中的这些 Sources 目录：</p><ul><li>&lt;Extract_Dir&gt;\Sources\hdl\top</li><li>&lt;Extract_Dir&gt;\Sources\hdl\shift_right</li></ul></li><li><p>单击下一步进入添加约束页面，然后选择这些文件：</p><ul><li>&lt;Extract_Dir&gt;\Sources\xdc\top_io_&lt;board&gt;.xdc</li><li>&lt;Extract_Dir&gt;\Sources\xdc\pblocks_&lt;board&gt;.xdc</li></ul><p> 请注意，这些约束文件是完整的设计约束，仅限于顶层设计。如果您想执行自己的布局规划，只需选择 top_io xdc，省略 Pblocks XDC。综合后停止流程以创建您自己的平面图。</p></li><li><p>单击下一步选择部件。在 Default Part 页面中，单击 Boards 并选择与您选择的约束文件匹配的目标板。然后单击下一步，然后单击完成以完成项目创建。 Sources 窗口显示设计的标准分层视图。<br><img src="https://m1.im5i.com/2022/08/23/UqdaDo.png" alt="好康的壁纸"><br>此时，打开了一个标准项目。没有针对 Dynamic Function eXchange 做任何事情。</p></li><li><p>选择工具 → 启用动态函数交换。<br> 这为 DFX 设计流程准备了项目。一旦设置，就无法撤消，因此请在选择此选项之前存档您的项目。<br><img src="https://m1.im5i.com/2022/08/20/UqD3iM.png" alt="好康的壁纸"><br>在随后出现的对话框中，单击转换以将此项目转换为 DFX 项目。<br><img src="https://m1.im5i.com/2022/08/20/UqD4c3.png" alt="好康的壁纸"><br>完成后左侧会出现DFX向导，但是还没有创建分区定义，暂时无法使用。</p></li><li><p>右键单击​​“shift”实例之一并选择“创建分区定义”选项。</p><p> 此操作会将两个 shift 实例定义为设计中的可重新配置分区。由于每个实例都来自相同的 RTL 源，因此它们在逻辑上是相同的。将运行上下文外综合以使该模块与顶部分离，并且一个综合后检查点将用于两个 shift 实例。<br><img src="https://m1.im5i.com/2022/08/23/UqdlkW.png" alt="创建分区定义"></p><blockquote><p>提示：如果设计中有同一模块的多个实例化，但并非所有实例都需要重新配置，则必须手动修改模块以使其成为唯一的。然后，您可以将所需的实例单独标记为可重新配置的分区。</p></blockquote></li><li><p>在出现的对话框中，为 Partition Definition 和 Reconfigurable Module 命名。分区定义是所有可重新配置模块都将插入其中的工作区的一般参考，因此请给它一个适当的名称，例如 shifter。 Reconfigurable Module 引用这个特定的 RTL 实例，因此给它一个引用其功能的名称，例如 shift_right，然后单击 OK。<br><img src="https://m1.im5i.com/2022/08/23/Uqdyax.png" alt="创建分区定义"></p><p> Sources 窗口现在略有变化，两个 shift 实例现在都显示为黄色菱形，表示它们是 Partitions。您还将在此窗口中看到一个分区定义选项卡，其中显示了设计中所有分区定义（此时为一个）的列表和内容。此外，还创建了一个脱离上下文的模块运行，用于合成 shift_right 模块。<br><img src="https://m1.im5i.com/2022/08/23/Uqd6AQ.png" alt="创建分区定义"></p><p> 此时，可能会添加更多 Reconfigurable Module 源。这是通过动态函数交换向导完成的。</p><blockquote><p>重要！定义分区后，必须通过 DFX 向导添加所有其他 RM，并且还必须通过此向导完成对 RM 源、配置和运行的任何管理。</p></blockquote></li></ol><h3 id="三、使用动态函数切换（DFX）向导完成设计">三、使用动态函数切换（DFX）向导完成设计</h3><ol><li><p>通过在工具菜单下或Flow Navigator中选择此选项来启动Dynamic Function eXchange Wizard。</p></li><li><p>单击 Next 进入 Edit Reconfigurable Modules 页面。在这里您可以看到 shift_right RM 已经存在，并且在窗口左侧的 RM 上方有添加、删除和编辑按钮。单击蓝色 + 图标以添加新的 RM。</p></li><li><p>单击添加目录按钮选择 shift_left 文件夹：</p> <pre class="line-numbers language-none"><code class="language-none">&lt;Extract_Dir&gt;\Sources\hdl\shift_left<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 或者使用 Add Files 按钮选择驻留在此目录中的 shift_left.v 文件。如果需要模块级约束，将在此处添加它们。请注意，它们需要限定在此分区的层次结构级别。<br> 将 Reconfigurable Module 字段填写为 shift_left。将 Partition Definition 设置为 shifter，将 Top Module 字段留空，并且 Sources are already综合复选框未选中。单击确定以创建新模块。<br> 现在有两个可重构模块可用于移位器可重构分区。<br><img src="https://m1.im5i.com/2022/08/23/UqdoVX.png" alt="创建分区定义"><br> 在下一页上，定义了配置。配置是由静态设计和每个 RP 一个 RM 组成的完整设计图像。您可以创建任何所需的配置集，也可以让向导为您选择它们​​。</p></li><li><p>让向导通过选择自动创建配置链接来创建配置。<br><img src="https://m1.im5i.com/2022/08/23/UqdtQf.png" alt="创建分区定义"><br> 选择此选项后，已创建最小的两个配置集。每个 shift 实例在第一个配置中被赋予 shift_right，在第二个配置中被赋予 shift_left。请注意，配置名称是可编辑的——在下面的示例中，名称已更新为 config_right 和 config_left 以反映每个模块中包含的可重新配置模块。<br><img src="https://m1.im5i.com/2022/08/23/Uqd1UM.png" alt="创建分区定义"><br> 使用这两个可重配置模块可以创建其他配置，但是创建此版本设计所需的所有部分比特流只需要两个，因为任何 RP 的最大 RM 数量是两个。</p></li><li><p>单击下一步进入编辑配置运行页面。<br> 与配置本身一样，用于实现每个配置的运行可以自动或手动创建。父子关系将定义运行如何交互——父运行实现静态设计和该配置中的所有 RM，然后子运行重用锁定的静态设计，同时在已建立的上下文中实现该配置中的 RM。</p></li><li><p>单击<strong>automatically create configuration run</strong>链接以使用最少的运行集填充配置运行页面。<br><img src="https://m1.im5i.com/2022/08/23/UqdBk3.png" alt="父子配置运行"><br> 这将创建两个运行，由​​一个父配置 (config_right) 和一个子配置 (config_left) 组成。可以在此向导中创建任意数量的独立或相关运行，并可选择为其中任何一个使用不同的策略或约束集。现在，将此设置保留为此处设置的两次运行。请注意，运行的名称不可编辑。</p></li><li><p>单击 Next 以查看 Summary 页面，然后单击 Finish 完成设计设置并退出向导。</p><blockquote><p>重要！在您单击完成退出 DFX 向导之前，不会创建或修改任何内容。在最后一次单击之前，所有操作都会排队，因此可以根据需要前进和后退，而无需实施更改，直到您准备好为止。</p></blockquote><p> 回到 Vivado® IDE，您将看到 Design Runs 窗口已更新。为 shift_left RM 添加了第二个上下文外综合运行，并在父 (impl_1) 下创建了子实现运行 (child_0_impl_1)。您现在已准备好处理设计。<br><img src="https://m1.im5i.com/2022/08/23/Uqdua7.png" alt="父子配置运行"></p></li></ol><h3 id="四、综合和实现当前设计">四、综合和实现当前设计</h3><p> 在 Vivado® IDE 中打开上述设计后，检查 Design Runs 窗口。顶层设计综合运行 (synth_1) 和父实现运行 (impl_1) 标记为“active”。 Flow Navigator 操作适用于这些活动运行及其子运行，因此单击 Run Synthesis 或 Run Implementation 将仅通过这些运行以及完成它们所需的 OOC 综合运行来拉动设计。您可以选择特定的父或子实现运行，右键单击并选择启动运行以拉动该最终目标的整个流程。</p><ol><li><p>在 Flow Navigator 中，单击 Run Synthesis → Open Synthesized Design。</p><blockquote><p>注意！！！！<br>我在这一步综合出错，无法继续，报错信息已提交赛灵思中文论坛：<a href="https://support.xilinx.com/s/question/0D54U00005WboT1SAJ/%E5%9C%A8%E8%B7%91ug947%E6%96%87%E6%A1%A3dfx-rtl-project-flow%E4%BE%8B%E7%A8%8B%E6%97%B6%E7%AC%AC%E5%9B%9B%E6%AD%A5%E7%BB%BC%E5%90%88%E6%8A%A5%E9%94%99%E6%8A%A5%E9%94%99%E4%BF%A1%E6%81%AF%E5%A6%82detail%E4%B8%AD%E5%9B%BE%E6%96%87%E6%A1%A3%E7%89%88%E6%9C%AC%E4%B8%BA20221%E7%9B%AE%E6%A0%87%E7%89%88%E9%80%89%E6%8B%A9%E4%B8%BAkcu105?language=en_US%E3%80%82">https://support.xilinx.com/s/question/0D54U00005WboT1SAJ/在跑ug947文档dfx-rtl-project-flow例程时第四步综合报错报错信息如detail中图文档版本为20221目标版选择为kcu105?language=en_US。</a><br>改用2020版本文件后正常综合，然后我又重新下载2022版本例程文件，并且​用一样的流程到综合这里，仍然报相同的错误，因此本文接下来均以2020版例程文件为基础。</p></blockquote><p> 该动作将综合所有OOC模块，然后综合顶层设计。<br> 这与任何带有 OOC 模块（IP 或其他）的设计没有什么不同。<br> 在打开的综合后设计中，请注意已经定义了两个 Pblock。这些在 pblocks_&lt;board&gt;.xdc 中提供，并映射到顶部的两个shift实例。如果设计源中不存在任何 Pblock，则可以在流程中的这一步创建它们。这可以通过右键单击设计层次结构中的 inst_shift 实例来选择 Floorplanning → Draw Pblock 来完成。每个实例都需要自己独特的 Pblock(在上一篇文章中UltraScale flow中有创建pblock这一步骤)。<br><img src="https://m1.im5i.com/2022/08/23/Uqd3Ip.png" alt="父子配置运行"></p></li><li><p>在平面图中选择两个 Pblock 之一并注意其属性。列出的最后两个属性是 RESET_AFTER_RECONFIG（仅限 7 系列）和 SNAPPING_MODE，这是 DFX 特有的两个属性。请注意，这两个选项都已在 Pblocks xdc 中启用。<br><img src="https://m1.im5i.com/2022/08/23/UqdAEv.png" alt="DFX特有属性"></p></li><li><p>通过选择 Reports → Report DRC 运行 DFX 特定的设计规则检查。为了节省时间，您可以取消选择除 Dynamic Function eXchange 之外的所有复选框。<br> DRC 检查将报告提供的源和约束没有错误。可能会为某些设备提供咨询消息，并提供有关如何提高给定 Pblock 质量的建议。对于这个简单的设计，这些可以忽略不计。<br><img src="https://m1.im5i.com/2022/08/23/UqdI7G.png" alt="DRC报告"><br> 如果您创建了自己的平面图并且报告了 DRC，请在继续之前解决问题。请注意，这两个模块都需要 BRAM 资源，并记住 SNAPPING_MODE 将解决与水平或垂直对齐相关的任何错误。</p><blockquote><p>提示：尽早并经常运行 DFX 设计规则检查。</p></blockquote></li><li><p>在 Flow Navigator 中，选择 Run Implementation 以在所有配置上运行布局布线。<br> 此操作首先为 impl_1 运行实现，然后为 child_0_impl_1 运行。在幕后，Vivado 负责处理所有细节。除了在满足所有 DFX 要求的情况下为两次运行运行布局和布线之外，它还执行了一些特定于 DFX 的任务。 impl_1 完成后，Vivado 自动：</p><ul><li>为每个路由 shift_right RM 写入模块级 (OOC) 检查点。</li><li>在每个 RP 中挖掘逻辑，为顶部创建仅静态的设计图像。这是通过为每个实例调用 update_design -black_box 来完成的。</li><li>锁定设计中纯静态部分的所有布局和布线。这是通过调用 lock_design 级路由来完成的。</li><li>保存锁定的静态父图像以供所有子运行重复使用。<br> 此外，当子运行完成时，会为路由的 shift_left RM 创建模块级检查点。锁定的静态设计图像将与父图像相同，因此不需要此步骤。<br> 如果只需要特定的配置运行，则可以在“Design Runs”窗口中单独选择这些配置。请注意，必须先成功完成父运行，然后才能启动子运行，因为子运行从父运行锁定静态设计开始。</li></ul></li><li><p>实施完成后，在弹出的对话框中单击取消。</p><blockquote><p>警告！即使设计已经处理到子实现运行，默认情况下，选择 Open Implemented Design 会打开父运行。使用下拉选项选择所需的实施运行。</p></blockquote><p><img src="https://m1.im5i.com/2022/08/23/UqdX1Y.png" alt="DRC报告"><br> 此时，还剩下两个步骤。首先是运行 PR 验证来比较两种配置，以确保设计图像的静态部分的一致性。强烈建议执行此步骤，并将在 Vivado 项目中自动执行。第二步是自己生成比特流。</p></li><li><p>在Flow Navigator中，单击<strong>Generate Bitstream</strong>。此操作在活动父运行上启动比特流生成，并启动 PR 验证，然后在所有实现的子运行上启动比特流生成。<br> 对于每次配置运行，默认情况下都会生成完整和部分比特流。</p></li></ol><p> 整个 Dynamic Function eXchange 流程可以在项目环境中运行。从模块级综合到比特流生成的所有步骤都可以在不离开 GUI 的情况下完成。</p><h3 id="五、添加额外的可重构模型和相应的配置">五、添加额外的可重构模型和相应的配置</h3><ol><li><p>在 Vivado IDE 中打开设计后，打开 Dynamic Function eXchange Wizard。</p></li><li><p>在 Edit Reconfigurable Modules 页面上，单击 + 按钮添加新 RM。</p></li><li><p>选择 &lt;Extract_Dir&gt;\Sources\hdl\shift_right_slow 中的 shift_right_slow.v 文件，然后单击 OK。</p></li><li><p>输入 shift_right_slow 作为 Reconfigurable Module 名称，然后单击 OK 和 Next。<br><img src="https://m1.im5i.com/2022/08/23/UqdHgw.png" alt="DRC报告"><br> 请注意，在“编辑配置”页面上，不再有自动创建配置的选项，因为您已经有两个现有配置。您可以通过删除所有现有配置重新启用此选项，但这将重新创建所有配置并删除所有现有结果。</p></li><li><p>单击 + 按钮创建新配置，输入名称 config_right_slow，然后按 ENTER。为每个 Reconfigurable Partition 实例选择 shift_right_slow。<br><img src="https://m1.im5i.com/2022/08/23/UqdPWF.png" alt="DRC报告"></p></li><li><p>单击下一步进入配置运行。使用 + 按钮创建具有以下属性的新配置：</p><ul><li>运行：child_1_impl_1 - 这与现有约定简单匹配</li><li>父级：impl_1 - 这使此配置成为现有父级运行的子运行</li><li>配置：config_right_slow - 这是一个使用刚刚定义的新 RM<br><img src="https://m1.im5i.com/2022/08/23/UqiDRd.png" alt="DRC报告"></li></ul></li><li><p>单击<strong>ok</strong>添加新的配置运行。<br> 这个新配置作为现有 impl_1 的子项，将重用静态设计实现结果，就像 config_left 一样。现在存在三个运行，其中两个作为初始父级的子级。绿色复选标记表示其中两个运行当前已完成。<br><img src="https://m1.im5i.com/2022/08/23/UqidUK.png" alt="DRC报告"></p></li><li><p>单击下一步，然后单击完成以构建这个新的配置运行。</p><p><img src="https://m1.im5i.com/2022/08/23/UqiiCC.png" alt="DRC报告"></p></li><li><p>选择这个新的子实现运行，右键单击并选择 Launch Runs。这将在 shift_right_slow 模块上运行 OOC 综合，然后在锁定静态设计的上下文中实现该模块。</p></li></ol><h3 id="六、创建和实现灰盒模块">六、创建和实现灰盒模块</h3><p> 对于某些设计，所需的设备初始配置可能是在可重配置分区中没有驻留功能的映像。或者也许还没有可重新配置的模块可以实现。灰盒配置可用于仅实现静态设计，而无需提供真正的 RM 网表。<br> 灰盒是一个以黑盒开始的模块，但随后会为所有端口自动插入 LUT。输出端口被驱动为逻辑 0（默认情况下，1 可通过属性选择），因此它们不会浮动。即使没有可用的 RM，该模块也允许处理设计。培训脚本可用于为该灰盒图像创建时序预算，优化静态设计的实现结果。具有灰盒 RM 的配置可以作为父运行，但仅在不存在其他 RM 和/或使用预算约束来优化 RP 接口布局时才建议这样做。</p><ol><li>打开动态功能交换 (DFX) 向导并移动到配置页面——在这种情况下不需要定义新的可重新配置模块，因为这是一个专用功能。创建一个名为 config_greybox 的新配置，并为每个 Reconfigurable Partition 实例输入 &lt;greybox&gt;。<br><img src="https://m1.im5i.com/2022/08/23/UqixaH.png" alt="DRC报告"></li><li>单击下一步进入配置运行页面，然后创建另一个新配置运行，这次是灰盒配置。<ul><li>父级：synth_1 – 这使得该配置成为新的父级，从综合顶层设计开始</li><li>配置：config_greybox – RM 仅包含 LUT 绑定</li><li>运行：impl_greybox<br><img src="https://m1.im5i.com/2022/08/23/UqiLIa.png" alt="DRC报告"><br><img src="https://m1.im5i.com/2022/08/23/UqigMT.png" alt="DRC报告"></li></ul></li><li>单击下一步，然后单击完成以创建此新运行。<br> 现在，Design Runs 窗口中显示了四个实现运行和三个脱离上下文的运行。请注意，灰盒模块不需要综合——它是 DFX 解决方案中的嵌入式功能。<br><img src="https://m1.im5i.com/2022/08/23/Uqis7A.png" alt="DRC报告"><br> 此时可以实现灰盒配置。</li><li>选择 impl_greybox 设计运行，右键单击并选择 Launch Runs。 Flow Navigator 不会启动此运行，因为它不是活动父级。<blockquote><p>重要！因为 impl_1 和 impl_greybox 都是双亲，所以它们的静态设计结果会有所不同，并且它们生成的比特流在硬件上将不兼容。只有从单个父级派生的比特流（随后使用 PR 验证进行确认）才能通过动态功能交换 (DFX) 传送到设备。</p></blockquote></li></ol><h3 id="七、修改设计源或选项">七、修改设计源或选项</h3><p> Vivado IDE 跟踪设计运行之间的依赖关系。考虑到配置的相互依赖性，这是 Dynamic Function eXchange 的一个关键特性。如果修改了父配置或实现结果的任何方面，则必须重新编译它和所有子代。</p><ol><li>选择 impl_1 design run。</li><li>在 Run Properties 窗口的 Options 选项卡中，将 Strategy 更改为 Performance_Explore。<br><img src="https://m1.im5i.com/2022/08/23/Uqirs0.png" alt="DRC报告"><br> 一个弹出对话框将提醒您，如果您继续，impl_1 将被强制过期。</li><li>单击是。<br> 多个运行现在被标记为过期：impl_1 和依赖它的两个子运行。生成的文件仍然存在于它们各自的文件夹中，但会在父运行启动后立即删除。另一方面，impl_greybox 设计运行仍然完成，因为它不依赖于 impl_1 作为父代。<br><img src="https://m1.im5i.com/2022/08/23/Uqi0WB.png" alt="DRC报告"><br> 请注意，每个子运行的 Strategy 选项保持在 Vivado Implementation<br>Defaults；子运行不继承父运行的选项。但是，子运行中的任何策略或选项只会对 Reconfigurable Module 实施产生影响，因为静态设计已经路由并锁定。</li><li>在 Flow Navigator 中，单击 Run Implementation。<br> 将出现一个对话框，确认您是否要在继续之前重置运行。因为过时的步骤是父运行的第一步，所以第一个选项将父运行和所有子运行完全重置到执行的开始。单击重置并重新运行或从步骤运行：phys_opt_design 继续。<br> 这实现了所有三个运行。首先，父 impl_1 运行将完成，然后两个子运行将并行运行。</li></ol><h3 id="总结">总结</h3><p> Dynamic Function eXchange Project Flow 具有很大的灵活性，使用户能够管理他们的设计环境并探索不同的选项。用户必须仔细跟踪实现结果和比特流，以确保只有从单个固定静态图像构建的兼容比特流被下载到目标设备。<br>参考：ug947-2022.1</p>]]></content>
    
    
    <summary type="html">接上一篇UltraScale DFX流程，本篇为RTL project流程</summary>
    
    
    
    <category term="DFX" scheme="https://naughtyrabbit.github.io/categories/DFX/"/>
    
    
    <category term="FPGA" scheme="https://naughtyrabbit.github.io/tags/FPGA/"/>
    
    <category term="DFX" scheme="https://naughtyrabbit.github.io/tags/DFX/"/>
    
    <category term="部分可重构" scheme="https://naughtyrabbit.github.io/tags/%E9%83%A8%E5%88%86%E5%8F%AF%E9%87%8D%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>私人日记-1</title>
    <link href="https://naughtyrabbit.github.io/2022/08/22/private-blog-1/"/>
    <id>https://naughtyrabbit.github.io/2022/08/22/private-blog-1/</id>
    <published>2022-08-22T14:26:24.000Z</published>
    <updated>2022-11-23T03:07:39.226Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>私人内容，请自重</p></blockquote><span id="more"></span>  <h3 id="一、苍蓝彼端的四重奏">一、苍蓝彼端的四重奏</h3><p> 久违的感动呢，虽然本身对体育竞速类项目没什么兴趣，即使这样也被作品感动着，日向和葵说他又开始飞了，他回来的时候，如鲠在喉呢。和石头门的凶真不断轮回救真由里和G弦上的魔王里最后主角在监狱里一个一个送走身边人的时候一样呢。</p><p><font face="楷体" color="SteelBlue"><center>  <p><strong>看看这天空吧</strong><br><strong>一直坚持看着吧</strong><br><strong>那里有着答案</strong></p></center></font></p>  <p><img src="https://m1.im5i.com/2022/08/22/UqdEh7.png" alt="好康的壁纸"><br><img src="https://m1.im5i.com/2022/08/22/UqdMJp.png" alt="好康的壁纸"><br><img src="https://m1.im5i.com/2022/08/22/Uqdj4v.png" alt="好康的壁纸"><br><img src="https://m1.im5i.com/2022/08/22/UqdZ0G.png" alt="好康的壁纸"></p><p> 担任搞笑的窗果很有意思呢(<em>^_^</em>)</p>]]></content>
    
    
    <summary type="html">私人内容，请自重</summary>
    
    
    
    <category term="私人日记" scheme="https://naughtyrabbit.github.io/categories/%E7%A7%81%E4%BA%BA%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="私人日记" scheme="https://naughtyrabbit.github.io/tags/%E7%A7%81%E4%BA%BA%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>兔言兔语——2</title>
    <link href="https://naughtyrabbit.github.io/2022/08/21/poem-2022-8-21/"/>
    <id>https://naughtyrabbit.github.io/2022/08/21/poem-2022-8-21/</id>
    <published>2022-08-21T14:21:03.000Z</published>
    <updated>2022-08-21T15:07:15.368Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一些乱写的东西，作个留念</p></blockquote><span id="more"></span><p><font face="楷体" color="SteelBlue"><center>  <p><strong>乱七八糟的句子</strong><br>1<br><strong>那一刻你的心里有一场海啸</strong><br><strong>你安静地站在那里</strong><br><strong>没有人知道</strong><br>2<br><strong>有朋自远方来，虽远必诛！</strong><br><strong>邹忌修八尺有余，而形貌昳丽，中通外直，不蔓不枝，香远益清，亭亭净植</strong></p></center></font></p><p><font face="楷体" color="SteelBlue"><center>  <p><strong>大圣归去</strong><br><strong>瑶池自饮闲愁，灵霄踏碎离忧</strong><br><strong>五行山下遇江流。</strong><br><strong>道是西游，成佛何游，</strong><br><strong>梦里琴奏。菩提陋</strong><br><strong>三更时候，一樽酒，</strong><br><strong>跪守柴门只等笑无由。</strong><br><strong>痴猴怎甘心羞，</strong><br><strong>老祖却只眉皱，</strong><br><strong>越水三秋，齐天妄想依旧。</strong><br><strong>尝登七楼，兜宫火苗不休。</strong><br><strong>谁系一叶扁舟，</strong><br><strong>浮沉渡口。</strong> </center><br></font></p></p><p><font face="楷体" color="SteelBlue"><center>   <p><strong>梦归园</strong><br><strong>人满巷，本无伤。</strong><br><strong>听寂静喧哗，看空空车马。</strong><br><strong>院中一点，梦归故园。</strong><br><strong>曾言妖伪，今思还谁？</strong><br><strong>仗剑旧友丛中戏，杆头新朋凄凄呖。</strong><br><strong>驾鹤故人名楼憩，愿为知己君无意。</strong><br><strong>紫藤枯枝影摇，枝头败叶冷笑。</strong><br><strong>满地残花无人扫，不期潇湘思野草。</strong><br><strong>冰雨侵寒屐，东风何处觅。</strong><br><strong>檐下数细雨，薜荔空自诩。</strong><br><strong>淡酒怎解满杯愁，木也飗飗，风也飗飗。</strong><br><strong>聒碎归想，惊洒孟汤。</strong><br><strong>恍惊起，孑身空巷。</strong></p> </center></font></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;一些乱写的东西，作个留念&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="兔言兔语" scheme="https://naughtyrabbit.github.io/categories/%E5%85%94%E8%A8%80%E5%85%94%E8%AF%AD/"/>
    
    
    <category term="个人随笔" scheme="https://naughtyrabbit.github.io/tags/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>FPGA_动态功能切换_UltraScale 基本 DFX 流程</title>
    <link href="https://naughtyrabbit.github.io/2022/08/20/FPGA-DFX-firstprj/"/>
    <id>https://naughtyrabbit.github.io/2022/08/20/FPGA-DFX-firstprj/</id>
    <published>2022-08-20T08:53:50.000Z</published>
    <updated>2022-08-22T03:57:28.340Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>UltraScale 基本 DFX 流程。目前动态可重构(Partial Reconfiguration) 已经更名为DFX(Dynamic Function eXchange, 动态功能切换)，方便软件工程师也能更容易理解这个Feature.​</p></blockquote><span id="more"></span><p>  本流程介绍 UltraScale™ 和 UltraScale+™ 器件的基本动态函数交换 (DFX) 流程。首先，您将使用脚本单独综合静态模块和每个可重新配置的设计模块变体。然后在 IDE 中，您将使用 Pblock 约束可重配置模块 (RM) 的位置并实现设计的初始配置。接下来，您将通过锁定设计的静态部分、使用变体更新可重新配置模块以及重新运行实现来实现替代配置。最后，您将验证每个实现的 RM 是否与设计的静态部分兼容，如果兼容，则生成比特流。</p><h3 id="一、解压例程-2">一、解压例程</h3><p>  根据ug947文档提示在赛灵思官网下载例程压缩包，定位到 <strong>\led_shift_count_us</strong> 文件夹为<strong>UltraScale</strong>系列例程，在2020.1版本中仅支持vcu118，在2022.1版本中新增了支持。需要注意的是例程是为KCU105, VCU108, KCU116, and VCU118这四块板子定做的。因为反正都没有，不上板的情况下使用2022版本例程文件学习。</p><h3 id="二、检查脚本">二、检查脚本</h3><p>  首先查看设计档案中提供的脚本。文件 run_dfx.tcl 和 advanced_settings.tcl 位于根级别。 run_dfx.tcl 脚本包含运行 Dynamic Function eXchange 所需的最低设置。 advanced_settings.tcl 包含默认流设置，只能由有经验的用户修改。</p><h4 id="1-主脚本：">1. 主脚本：</h4><p>  在 \led_shift_count_us 中，在文本编辑器中打开 run_dfx.tcl。这是您定义设计参数、设计源和设计结构的主脚本。这是编译完整的 Dynamic Function eXchange 设计时必须修改的唯一文件。在位于 Tcl_HD 子目录的 README.txt 中查找有关 run_dfx.tcl、advanced_settings.tcl 和底层脚本的更多详细信息。文件具体如下：<br><strong>run_dfx.tcl</strong></p><pre class="line-numbers language-tcl" data-language="tcl"><code class="language-tcl"><span class="token comment">###############################################################</span><span class="token comment">###  Minimum settings required to run DFX flow:</span><span class="token comment">###  1. Specify flow steps</span><span class="token comment">###  2. Define target board</span><span class="token comment">###  3. Identify source directories</span><span class="token comment">###  4. Define static module</span><span class="token comment">###  5. Define RPs, and their RM variants</span><span class="token comment">###############################################################</span><span class="token comment">####flow control (1 = run step , 0 = skip step)</span><span class="token keyword">set</span> <span class="token variable">run</span>.topSynth       1 ;<span class="token comment">#synthesize static</span><span class="token keyword">set</span> <span class="token variable">run</span>.rmSynth        1 ;<span class="token comment">#synthesize RM variants</span><span class="token keyword">set</span> <span class="token variable">run</span>.dfxImpl        0 ;<span class="token comment">#implement each static + RM configuration</span><span class="token keyword">set</span> <span class="token variable">run</span>.prVerify       0 ;<span class="token comment">#verify RMs are compatible with static</span><span class="token keyword">set</span> <span class="token variable">run</span>.writeBitstream 0 ;<span class="token comment">#generate full and partial bitstreams</span><span class="token comment">###############################################################</span><span class="token comment">### Define target demo board</span><span class="token comment">### Valid values are kcu105, vcu108, kcu116 and vcu118</span><span class="token comment">### Select one only</span><span class="token comment">###############################################################</span><span class="token keyword">set</span> <span class="token variable">xboard</span>        <span class="token string">"kcu105"</span><span class="token comment">###############################################################</span><span class="token comment">###  Run Settings</span><span class="token comment">###############################################################</span><span class="token comment">####Input Directories</span><span class="token keyword">set</span> <span class="token variable">srcDir</span>     <span class="token string">"./Sources"</span><span class="token keyword">set</span> <span class="token variable">rtlDir</span>     <span class="token string">"$srcDir/hdl"</span><span class="token keyword">set</span> <span class="token variable">prjDir</span>     <span class="token string">"$srcDir/prj"</span><span class="token keyword">set</span> <span class="token variable">xdcDir</span>     <span class="token string">"$srcDir/xdc"</span><span class="token keyword">set</span> <span class="token variable">coreDir</span>    <span class="token string">"$srcDir/cores"</span><span class="token keyword">set</span> <span class="token variable">netlistDir</span> <span class="token string">"$srcDir/netlist"</span><span class="token comment">####Output Directories</span><span class="token keyword">set</span> <span class="token variable">synthDir</span>  <span class="token string">"./Synth"</span><span class="token keyword">set</span> <span class="token variable">implDir</span>   <span class="token string">"./Implement"</span><span class="token keyword">set</span> <span class="token variable">dcpDir</span>    <span class="token string">"./Checkpoint"</span><span class="token keyword">set</span> <span class="token variable">bitDir</span>    <span class="token string">"./Bitstreams"</span><span class="token comment">###############################################################</span><span class="token comment">### Static Module Definition</span><span class="token comment">###############################################################</span><span class="token keyword">set</span> <span class="token variable">top</span> <span class="token string">"top"</span><span class="token comment">###############################################################</span><span class="token comment">### RP &amp; RM Definitions (Repeat for each RP)</span><span class="token comment">### 1. Define Reconfigurable Partition (RP) name</span><span class="token comment">### 2. Associate Reconfigurable Modules (RMs) to the RP</span><span class="token comment">###############################################################</span><span class="token keyword">set</span> <span class="token variable">rp1</span> <span class="token string">"shift"</span><span class="token keyword">set</span> <span class="token variable">rm_variants</span><span class="token punctuation">(</span>$<span class="token variable">rp1</span><span class="token punctuation">)</span> <span class="token string">"shift_right shift_left"</span><span class="token keyword">set</span> <span class="token variable">rp2</span> <span class="token string">"count"</span><span class="token keyword">set</span> <span class="token variable">rm_variants</span><span class="token punctuation">(</span>$<span class="token variable">rp2</span><span class="token punctuation">)</span> <span class="token string">"count_up count_down"</span><span class="token comment">########################################################################</span><span class="token comment">### RM Configurations (Valid combinations of RM variants)</span><span class="token comment">### 1. Define initial configuration: rm_config(initial)</span><span class="token comment">### 2. Define additional configurations: rm_config(xyz)</span><span class="token comment">########################################################################</span><span class="token keyword">set</span> <span class="token variable">module1_variant1</span> <span class="token string">"shift_right"</span><span class="token keyword">set</span> <span class="token variable">module2_variant1</span> <span class="token string">"count_up"</span><span class="token keyword">set</span> <span class="token variable">rm_config</span><span class="token punctuation">(</span>initial<span class="token punctuation">)</span>   <span class="token string">"$rp1 $module1_variant1 $rp2 $module2_variant1"</span><span class="token keyword">set</span> <span class="token variable">module1_variant2</span> <span class="token string">"shift_left"</span><span class="token keyword">set</span> <span class="token variable">module2_variant2</span> <span class="token string">"count_down"</span><span class="token keyword">set</span> <span class="token variable">rm_config</span><span class="token punctuation">(</span>reconfig1<span class="token punctuation">)</span> <span class="token string">"$rp1 $module1_variant2 $rp2 $module2_variant2"</span><span class="token comment">########################################################################</span><span class="token comment">### Task / flow portion</span><span class="token comment">########################################################################</span><span class="token comment"># Build the designs</span><span class="token keyword">source</span> .<span class="token operator">/</span>advanced_settings.tcl<span class="token keyword">source</span> $<span class="token variable">tclDir</span><span class="token operator">/</span>run.tcl<span class="token comment">#exit ;#uncomment if running in batch mode</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  请注意此run_dfx.tcl 中的以下详细信息：</p><ul><li>在Define target demo board 下，您可以选择此设计支持的众多演示板之一。</li><li>在flow control下，您可以控制运行综合和实现的哪些阶段。在本教程中，脚本只运行合成；实现、验证和比特流生成以交互方式运行。要通过脚本运行这些附加步骤，请将流变量（例如，run.prImpl）设置为 1。</li><li>Output Directories and Input Directories设置设计源和结果文件的预期文件结构。您必须在此处反映对文件结构的任何更改。</li><li>Top Definition和RP Module Definitions部分让您可以参考设计每个部分的所有源文件。顶层定义涵盖了静态设计所需的所有资源，包括约束和 IP。 RP Module Definitions 部分对 Reconfigurable Partitions (RP) 执行相同的操作。识别每个 RP 并列出每个 RP 的所有可重构模块 (RM) 变体。<ul><li>此设计有两个 Reconfigurable Partitions（inst_shift 和 inst_count），每个 RP 有两个模块变体。</li></ul></li><li>Configuration Definition部分定义构成配置的静态和可重新配置模块集。<ul><li>此设计在主脚本中定义了两种配置：config_shift_right_count_up_implement 和 config_shift_left_count_down_import。</li><li>您可以通过添加 RM 或组合现有 RM 来创建更多配置。</li></ul></li></ul><h4 id="2-子脚本：">2. 子脚本：</h4><p>  在 Tcl_HD 子目录下，存在几个辅助的 Tcl 脚本。这些脚本由 run_dfx.tcl 调用，它们管理 Dynamic Function eXchange 流的特定细节。下面提供了一些关于一些关键 DFX 脚本的详细信息。（官方文档中提示禁止修改这些脚本，只能修改主脚本参数）</p><ul><li>step.tcl：通过监控检查点来管理设计的当前状态。</li><li>synthesize.tcl：管理关于综合阶段的所有细节。</li><li>implement.tcl：管理有关模块实现阶段的所有细节。</li><li>dfx_utils.tcl：管理有关DFX 设计顶层实现的所有细节。</li><li>run.tcl：启动综合和实现的实际运行。</li><li>log_utils.tcl：处理流程中关键点的报告文件创建。</li><li>其余脚本在这些脚本中提供详细信息（例如其他 *_utils.tcl 脚本）或管理其他分层设计流程（例如 hd_utils.tcl）。</li></ul><h3 id="三、综合设计">三、综合设计</h3><p>  run_dfx.tcl 脚本自动完成本教程的综合阶段。调用了五次综合迭代，一次用于静态顶层设计，一次用于四个可重配置模块中的每一个。</p><ol><li><p>打开 Vivado Tcl shell：</p><ul><li>在 Windows 上，选择 Xilinx Vivado 桌面图标或开始 → 所有程序 → Xilinx 设计工具 → Vivado 2022.1 → Vivado 2022.1 Tcl Shell。</li><li>在Linux 上，只需键入vivado -mode tcl。</li></ul></li><li><p>在 shell 中，导航到 \led_shift_count_us。</p></li><li><p>如果您使用的目标演示板不是 KCU105，请修改 run_dfx.tcl 中的 xboard 变量。有效的替代品是 VCU108、KCU116 和 VCU118 板。</p></li><li><p>输入以下命令运行 run_dfx.tcl 脚本：</p><pre class="line-numbers language-none"><code class="language-none">source run_dfx.tcl -notrace   <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>完成所有五次 Vivado 综合后，Vivado Tcl shell 保持打开状态。您可以在 Synth 子目录中的每个命名文件夹下找到每个模块的日志和报告文件，以及最终检查点。</p><blockquote><p>提示：在 \led_shift_count_us 中，创建了多个日志文件：<br>• run.log 显示发布在 Tcl shell 窗口中的摘要<br>• command.log 回显脚本运行的所有单独步骤<br>• critical.log 报告在运行期间产生的所有严重警告运行</p></blockquote></li></ol><p>  打开tcl控制台，切换到目标目录，注意路径采用 / 分隔而不是资源管理器直接复制来的 \ 。执行source run_dfx.tcl -notrace命令，可以看到vivado在进行5次综合。<br><img src="https://m1.im5i.com/2022/08/21/UqUjGB.png" alt="打开tcl控制台"><br>  一段时间后综合完成：<br><img src="https://m1.im5i.com/2022/08/21/UqUTNz.png" alt="综合完成"></p><h3 id="四、组装和实现设计">四、组装和实现设计</h3><p>  现在每个模块的综合检查点以及顶部都可用，您可以组装设计。<br>  您将从 Tcl 控制台运行所有流程步骤，但您可以使用 IDE 中的功能（例如布局规划工具）进行交互式事件。</p><ol><li><p>打开 Vivado IDE。您可以通过键入 start_gui 或使用命令 vivado -mode gui 启动 Vivado 从打开的 Tcl shell 打开 IDE。</p></li><li><p>导航到 <s>\led_shift_count_7s</s>(很明显官方文档书写错误，U+系列的应该还是\led_shift_count_us，估计写文档的在复制粘贴 -.- )。如果您还没有。 pwd 命令可以确认这一点。</p></li><li><p>设置有助于将本文档中的命令复制到 Tcl 控制台的变量。选择您针对此教程的器件和电路板，然后在 Vivado 中应用它们：</p> <pre class="line-numbers language-none"><code class="language-none">set part &quot;xcku040-ffva1156-2-e&quot;  set board &quot;kcu105&quot;  set part &quot;xcvu095-ffva2104-2-e&quot;  set board &quot;vcu108&quot;  set part &quot;xcku5p-ffvb676-2-e&quot;  set board &quot;kcu116&quot;  set part &quot;xcvu9p-flga2104-2l-e&quot;  set board &quot;vcu118&quot;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>通过在 Tcl 控制台中发出以下命令创建内存中设计： create_project -in_memory -part $part</p></li><li><p>通过发出以下命令加载静态设计： add_files ./Synth/Static/top_synth.dcp</p></li><li><p>加载通过发出以下命令设置顶层设计约束:</p> <pre class="line-numbers language-none"><code class="language-none">add_files .&#x2F;Sources&#x2F;xdc&#x2F;top_io_$board.xdc   set_property USED_IN &#123;implementation&#125; [get_files .&#x2F;Sources&#x2F;xdc&#x2F;top_io_ $board.xdc]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>  选择 top_io_$board 版本的可用的 xdc 文件加载管脚位置和时钟约束，但不包括布局规划信息。 top_$board 版本包括引脚位置、时钟和布局规划约束。</p></li><li><p>通过发出以下命令为 shift 和 count 函数加载前两个综合检查点：</p><pre class="line-numbers language-none"><code class="language-none">add_files .&#x2F;Synth&#x2F;shift_right&#x2F;shift_synth.dcp   set_property SCOPED_TO_CELLS &#123;inst_shift&#125; [get_files .&#x2F;Synth&#x2F;shift_right&#x2F;shift_synth.dcp]   add_files .&#x2F;Synth &#x2F;count_up&#x2F;count_synth.dcp   set_property SCOPED_TO_CELLS &#123;inst_count&#125; [get_files .&#x2F;Synth&#x2F;count_up&#x2F;count_synth.dcp]  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>  SCOPED_TO_CELLS 属性确保对目标单元进行正确分配。如需了解更多信息，请参阅 Vivado Design Suite 用户指南：使用约束 (UG903) 中的此链接。</p></li><li><p>使用 link_design 命令将整个设计链接在一起：</p> <pre class="line-numbers language-none"><code class="language-none">link_design -mode default -reconfig_partitions &#123;inst_shift inst_count&#125; -part $part -top top <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>  此时加载了完整的配置，包括静态和可重新配置的逻辑。请注意，当您在非项目模式下工作时，Flow Navigator 窗格不存在。</p><blockquote><p>提示：通过选择布局 → 布局规划将 IDE 置于布局规划模式。确保“设备”窗口可见。</p></blockquote></li><li><p>保存此初始配置的组装设计状态：</p><pre class="line-numbers language-none"><code class="language-none">write_checkpoint .&#x2F;Checkpoint&#x2F;top_link_right_up.dcp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><p> 配置完成后界面如下：<br><img src="https://m1.im5i.com/2022/08/21/UqUhxs.png" alt="综合完成"></p><h3 id="五、建立设计平面图">五、建立设计平面图</h3><p>  接下来，创建一个平面图来定义 Dynamic Function eXchange 的区域。</p><ol><li><p>在 Netlist 窗口中选择 inst_count 实例。右键选择Floorplanning→Draw Pblock，在设备左上角左侧画一个高的窄框。此时，确切的大小和形状并不重要，但请将框保持在时钟区域内。</p><p>在继续之前，请确保在 Device 窗口中选择了 Pblock。</p><p>尽管此 Reconfigurable Module 仅需要 CLB 资源，但如果框包含这些类型，还包括 RAMB18、RAMB36 或 DSP48 资源。这允许这些块类型的路由资源包含在可重新配置区域中。如果需要，可以使用 Pblock Properties 窗口的 General 视图添加这些。 Statistics 视图显示当前加载的 Reconfigurable Module 的资源需求。</p><p><img src="https://m1.im5i.com/2022/08/21/UqUkqo.png" alt="draw_pblock"><br><img src="https://m1.im5i.com/2022/08/21/UqUC6W.png" alt="pblock"></p></li><li><p>对 inst_shift 实例重复上一步，这次针对第一个下方的时钟区域。此 Reconfigurable Module 包含 Block RAM 实例，因此必须包含资源类型。如果省略，统计视图中的 RAMB 详细信息将显示为红色。<br><img src="https://m1.im5i.com/2022/08/21/UqUcHx.png" alt="重复画一个pblock"><br><img src="https://m1.im5i.com/2022/08/21/UqU8TQ.png" alt="包含资源类型和统计数据"></p></li><li><p>通过选择 Reports → Report DRC 运行 Dynamic Function eXchange 设计规则检查。您可以取消选中所有规则，然后选中 Dynamic Function eXchange 以使此报告严格关注 DFX DRC。<br><img src="https://m1.im5i.com/2022/08/21/UqUFeq.png" alt="选择规则"></p><p>只要 inst_shift Pblock 包含 RAMB18 和 RAMB36 资源，就不应报告 DRC 错误。可能仍会报告建议消息，尤其是当 Pblock 位于设备边缘附近时。请注意，对于两个 Pblock，SNAPPING_MODE 都设置为 ON，如 Pblock Properties 窗口的 Properties 视图中所述。鉴于此架构中可编程单元的精细粒度，所有 UltraScale 和 UltraScale+ 设备始终启用此功能。<br><img src="https://m1.im5i.com/2022/08/21/UqUV3D.png" alt="选择规则"></p></li><li><p>保存这些 Pblock 和相关属性：</p> <pre class="line-numbers language-none"><code class="language-none">write_xdc .&#x2F;Sources&#x2F;xdc&#x2F;top_all.xdc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这会导出设计中的所有当前约束，包括之前从 top_io_$board.xdc 导入的约束。这些约束可以在它们自己的 XDC 文件中管理或在运行脚本中管理（通常使用 HD.RECONFIGURABLE 完成）。<br>或者，可以单独提取和管理 Pblock 约束本身。 Tcl proc 可用于帮助执行此任务。</p><p>a. 首先获取在 Tcl 实用程序文件之一中找到的 proc：</p> <pre class="line-numbers language-none"><code class="language-none">source .&#x2F;Tcl_HD&#x2F;hd_utils.tcl<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>b. 然后使用 export_pblocks proc 写出此约束信息：</p> <pre class="line-numbers language-none"><code class="language-none">export_pblocks -file .&#x2F;Sources&#x2F;xdc&#x2F;pblocks.xdc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>  这将为设计中的两个 Pblock 写入 Pblock 约束信息。如果需要，使用 pblocks 选项仅选择一个。</p></li></ol><h3 id="六、实现第一个配置">六、实现第一个配置</h3><p>  在此步骤中，您对设计进行布局和布线，并准备设计的静态部分，以便与新的可重配置模块一起重复使用。</p><h4 id="设计实现">设计实现</h4><ol><li>通过发出以下命令来优化、布局和布线设计：</li></ol>   <pre class="line-numbers language-none"><code class="language-none">opt_designplace_designroute_design<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在 place_design 和 route_design 之后，在 Device 视图中检查设计的状态（参见下图）。在 place_design 之后需要注意的一件事是引入了分区引脚。这些是静态和可重新配置逻辑之间的物理接口点。它们是互连块中的锚点，可重配置模块的每个 I/O 都必须通过这些锚点进行路由。它们在放置的设计视图中显示为白框。对于 pblock_shift，它们出现在该 Pblock 的顶部，因为到静态的连接就在设备该区域的 Pblock 之外。对于 Pblock_count，它们出现在用户定义的区域之外，因为 SNAPPING_MODE 垂直收集了更多要添加到 Reconfigurable Partition 的帧。<br><img src="https://m1.im5i.com/2022/08/21/UqU5py.png" alt="优化和布局布线之后"></p><ol start="2"><li>要在 GUI 中轻松找到这些分区引脚：<br>a. 在 Netlist 窗格中选择 Reconfigurable Module（例如，inst_shift）<br>b. 在Cell Properties窗格中选择Cell Pins选项卡。</li><li>选择任何引脚以突出显示它，或使用 Ctrl+A 全选。后者的 Tcl 等效项是：  <pre class="line-numbers language-none"><code class="language-none">select_objects [get_pins inst_shift&#x2F;*]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><pre><code>![分区引脚](https://m1.im5i.com/2022/08/21/UqUGbh.png)</code></pre><ol start="4"><li>使用 Routing Resources 工具栏按钮在抽象和实际路由信息之间切换，并更改路由资源本身的可见性。此时设计中的所有网络都已完全布线。<br><img src="https://m1.im5i.com/2022/08/21/UqUbNX.png" alt="分区引脚"></li></ol><h4 id="保存结果">保存结果</h4><ol><li><p>通过发出以下命令保存完整的设计检查点并创建报告文件：</p> <pre class="line-numbers language-none"><code class="language-none">write_checkpoint -force Implement&#x2F;Config_shift_right_count_up_implement&#x2F;top_route_design.dcpreport_utilization -file Implement&#x2F;Config_shift_right_count_up_implement&#x2F;top_utilization.rptreport_timing_summary -file Implement&#x2F;Config_shift_right_count_up_implement&#x2F;top_timing_summary.rpt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>[可选] 通过发出以下两个命令为每个可重新配置模块保存检查点：</p> <pre class="line-numbers language-none"><code class="language-none">write_checkpoint -force -cell inst_shift Checkpoint&#x2F;shift_right_route_design.dcpwrite_checkpoint -force -cell inst_count Checkpoint&#x2F;count_up_route_design.dcp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>提示：运行 run_dfx.tcl 以批处理模式处理整个设计时，会在流程的每个步骤中创建设计检查点、日志文件和报告文件。</p></blockquote><p>至此，您已经创建了一个完全实现的 Dynamic Function eXchange 设计，您可以从中生成全部和部分比特流。此配置的静态部分用于所有后续配置。要隔离静态设计，请移除当前的 Reconfigurable Modules。确保启用路由资源，并放大到带有分区引脚的互连块。</p></li><li><p>通过发出以下命令清除 Reconfigurable Module 逻辑：</p> <pre class="line-numbers language-none"><code class="language-none">update_design -cell inst_shift -black_boxupdate_design -cell inst_count -black_box<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>发出这些命令会导致许多设计更改，如下图所示：<br>• 全布线网络（绿色）的数量减少。<br>• inst_shift 和inst_count 现在在网表视图中显示为空。<br><img src="https://m1.im5i.com/2022/08/21/UqU2xf.png" alt="全布线网络（绿色）的数量减少"><br><img src="https://m1.im5i.com/2022/08/21/UqU78M.png" alt="全布线网络（绿色）的数量减少"></p></li></ol><h4 id="关闭项目">关闭项目</h4><ol><li><p>发出以下命令以锁定所有布局和布线：</p> <pre class="line-numbers language-none"><code class="language-none">lock_design -level routing<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>因为在 lock_design 命令中没有识别出单元，所以内存中的整个设计（当前包括带有黑盒的静态设计）都会受到影响。所有布线网络现在都显示为锁定，如图 第7节图 中的虚线所示。所有放置的组件都从蓝色变为橙色，表明它们也被锁定。</p></li><li><p>发出以下命令以写出（write out）剩余的仅静态检查点：</p> <pre class="line-numbers language-none"><code class="language-none">write_checkpoint -force Checkpoint&#x2F;static_route_design.dcp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此仅静态检查点用于将来的配置。</p></li><li><p>在继续下一个配置之前关闭此设计：</p> <pre class="line-numbers language-none"><code class="language-none">close_project<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h3 id="七、实施第二个配置">七、实施第二个配置</h3><p>  现在静态设计结果已建立并锁定，您可以将其用作实现更多可重构模块的上下文。</p><h4 id="设计实现-2">设计实现</h4><ol><li><p>通过在 Tcl 控制台中发出以下命令来创建新的内存设计：</p> <pre class="line-numbers language-none"><code class="language-none">create_project -in_memory -part $part<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>通过发出以下命令加载静态设计：</p> <pre class="line-numbers language-none"><code class="language-none">add_files .&#x2F;Checkpoint&#x2F;static_route_design.dcp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>通过发出以下命令为移位和计数函数加载后两个综合检查点：</p> <pre class="line-numbers language-none"><code class="language-none">add_file .&#x2F;Synth&#x2F;shift_left&#x2F;shift_synth.dcpset_property SCOPED_TO_CELLS &#123;inst_shift&#125; [get_files .&#x2F;Synth&#x2F;shift_left&#x2F;shift_synth.dcp]add_file .&#x2F;Synth&#x2F;count_down&#x2F;count_synth.dcpset_property SCOPED_TO_CELLS &#123;inst_count&#125; [get_files .&#x2F;Synth&#x2F;count_down&#x2F;count_synth.dcp]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>使用 link_design 命令将整个设计链接在一起：</p> <pre class="line-numbers language-none"><code class="language-none">link_design -mode default -reconfig_partitions &#123;inst_shift inst_count&#125; -part $part -top top<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此时，已加载完整配置。然而，这一次，静态设计被路由和锁定，可重构逻辑仍然只是一个网表。此处的布局和布线仅适用于 RM 逻辑。</p></li><li><p>通过发出以下命令，在静态上下文中优化、放置和路由新的 RM：</p> <pre class="line-numbers language-none"><code class="language-none">opt_designplace_designroute_design<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p> 该设计再次完全实现，现在使用新的可重构模块变体。布线是虚线（锁定）和实线（新）布线段的混合，如下所示。<br><img src="https://m1.im5i.com/2022/08/22/UqUyrY.png" alt="第二个配置的布线"></p></li></ol><h4 id="保存结果-2">保存结果</h4><ol><li><p>通过发出以下命令保存完整的设计检查点和报告文件：</p> <pre class="line-numbers language-none"><code class="language-none">write_checkpoint -force Implement&#x2F;Config_shift_left_count_down_import&#x2F;top_route_design.dcpreport_utilization -file Implement&#x2F;Config_shift_left_count_down_import&#x2F;top_utilization.rptreport_timing_summary -file Implement&#x2F;Config_shift_left_count_down_import&#x2F;top_timing_summary.rpt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>[可选] 通过发出以下两个命令为每个可重新配置模块保存检查点：</p> <pre class="line-numbers language-none"><code class="language-none">write_checkpoint -force -cell inst_shift Checkpoint&#x2F;shift_left_route_design.dcpwrite_checkpoint -force -cell inst_count Checkpoint&#x2F;count_down_route_design.dcp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p> 至此，您已经实现了静态设计和所有 Reconfigurable Module 变体。对于每个可重构分区具有两个以上可重构模块的设计，将重复此过程。</p></li></ol><h3 id="八、使用高亮显示脚本检查结果">八、使用高亮显示脚本检查结果</h3><p> 在 IDE 中打开路由配置后，运行一些可视化脚本以突出显示拼贴和网络。这些脚本标识为 Dynamic Function eXchange 分配的资源并自动生成。</p><ol><li><p>在 Tcl 控制台中，从 \led_shift_count_us 目录发出以下命令：</p> <pre class="line-numbers language-none"><code class="language-none">source hd_visual&#x2F;pblock_inst_shift_Routing_AllTiles.tclhighlight_objects -color green [get_selected_objects]  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>单击设备视图中的某处以取消选择框架（或输入 unselect_objects），然后发出以下命令：</p> <pre class="line-numbers language-none"><code class="language-none">source hd_visual&#x2F;pblock_inst_shift_Placement_AllTiles.tclsource hd_visual&#x2F;pblock_inst_count_Placement_AllTiles.tclhighlight_objects -color blue [get_selected_objects]  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p> 分区帧在设备视图中高亮显示，如下图所示。<br><img src="https://m1.im5i.com/2022/08/22/UqU6bw.png" alt="全布线网络（绿色）的数量减少"><br> 这些突出显示的图块代表用于每个 RM 的布局（蓝色）和布线（绿色）的配置框架。绿色瓦片被发送到比特流生成以创建部分比特流（用于 inst_shift）。 SNAPPING_MODE 功能调整了 pblock_shift 的四个边缘中的三个，以说明与可编程单元边界的对齐。这种捕捉行为解释了为什么静态逻辑似乎已放置在可重新配置的分区内，如前面的步骤所示。实际上，有效边界是比用户定义的 Pblock 边界指示的 CLB 行高 1 行，因此这个静态逻辑放置正确。这个有效边界也可以在创建过程中 Pblock 的阴影中看到，如步骤 5：构建设计平面图所示。</p><blockquote><p>注意：包括与 Pblock 宽度匹配的 RCLK 行。这些可重配置分区中的全局时钟驱动逻辑连接到贯穿这些行的主干，并在动态功能交换期间启用或禁用。</p></blockquote><p> 其他“平铺”脚本是这些脚本的变体。如果您没有创建与时钟区域边界垂直对齐的 Pblock，FrameTiles 脚本将突出显示显式 Pblock 块，而 AllTiles 脚本将这些块扩展到完全可重新配置的帧高度。请注意，这些会在未选择的帧类型（例如全局时钟）存在的地方留下间隙。<br> GlitchTiles 脚本是框架站点的子集，避免了专用的硅资源；其他脚本比这个提供更多信息。</p></li><li><p>关闭当前设计：</p></li></ol><pre class="line-numbers language-none"><code class="language-none">close_project<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="九、生成比特流">九、生成比特流</h3><h4 id="确认配置">确认配置</h4><blockquote><p>建议：在生成比特流之前，验证所有配置以确保每个配置的静态部分完全匹配，因此生成的比特流可以安全地在硅片中使用。 PR 验证功能检查完整的静态设计，包括分区引脚，确认它们是相同的。未检查可重配置模块内的布局和布线，因为此处预计会有不同的模块结果。</p></blockquote><ol><li>从 Tcl 控制台运行 pr_verify 命令： <pre class="line-numbers language-none"><code class="language-none">pr_verify Implement&#x2F;Config_shift_right_count_up_implement&#x2F;top_route_design.dcp Implement&#x2F;Config_shift_left_count_down_import&#x2F;top_route_design.dcp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre> 如果成功，此命令将返回以下消息。 <pre class="line-numbers language-none"><code class="language-none">INFO: [Vivado 12-3253]PR_VERIFY: check points Implement&#x2F;Config_shift_right_count_up&#x2F;top_route_design.dcp and Implement&#x2F;Config_shift_left_count_down&#x2F;top_route_design.dcp are compatible<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><img src="https://m1.im5i.com/2022/08/22/UqUKoF.png" alt="全布线网络（绿色）的数量减少"><br> 默认情况下，仅报告第一个不匹配（如果有）。要查看所有不匹配，请使用 full_check 选项。</li><li>关闭当前设计：</li></ol><pre class="line-numbers language-none"><code class="language-none">close_project<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="生成比特流">生成比特流</h4><p> 现在配置已经过验证，您可以生成比特流并使用它们来定位您选择的演示板。</p><blockquote><p>注意：第一个配置实现 shift_right 和 count_up。第二个配置实现 shift_left 和 count_down。</p></blockquote><ol><li>将第一个配置读入内存： <pre class="line-numbers language-none"><code class="language-none">open_checkpoint Implement&#x2F;Config_shift_right_count_up_implement&#x2F;top_route_design.dcp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>为该设计生成全部和部分比特流。确保将位文件保存在与创建它们的完整设计检查点相关的唯一目录中。 <pre class="line-numbers language-none"><code class="language-none">write_bitstream -force -file Bitstreams&#x2F;Config_RightUp.bitclose_project<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>请注意，已创建五个（或三个，如果您使用的是 UltraScale+™ 设备）比特流：<br><img src="https://m1.im5i.com/2022/08/22/UqUQLd.png" alt="全布线网络（绿色）的数量减少"><ul><li>Config_RightUp.bit 这是上电的完整设计比特流。右侧的四个移位 LED 将向右移动，左侧的四个计数 LED 将向上计数。</li><li>Config_RightUp_pblock_inst_shift_partial.bit 这是 shift_right 模块的部分位文件，它导致移位 LED 右移。</li><li>Config_RightUp_pblock_inst_count_partial.bit 这是导致count LED 向上计数的count_up 模块的部分位文件。</li><li>Config_RightUp_pblock_inst_shift_partial_clear.bit 这是仅用于 UltraScale 器件的 shift_right 模块的清除位文件。它安全地清除右移以允许重新配置移位模块。</li><li>Config_RightUp_pblock_inst_count_partial_clear.bit 这是仅用于 UltraScale 器件的 count_up 模块的清除位文件。它安全地清除向上计数以允许重新配置计数模块。</li></ul><blockquote><p>重要的！当通过一次调用 write_bitstream 生成时，位文件的名称当前不反映 Reconfigurable Module 变体的名称，以阐明加载了哪个图像。当前解决方案使用 -file 选项给出的基本名称并附加可重构单元的 Pblock 名称。在基本名称中提供足够的描述以便能够清楚地识别可重新配置的位文件是至关重要的。所有部分位文件都有 _partial 后缀，所有清除位文件都有 _partial_clear 后缀。</p></blockquote></li></ol><p> 使用 run_dfx.tcl 通过比特流生成来处理整个设计，使用不同的技术来生成比特流。打开路由设计检查点会发出对 write_bitstream 的多次调用，这使您可以更好地控制命名比特流，并允许将不同的选项（如比特流压缩）应用于完整比特流和部分比特流。例如，run_dfx.tcl 脚本中配置的名称为：</p><ul><li>Config_shift_right_count_up_implement_full.bit 这是上电的完整设计比特流。</li><li>pblock_shift_shift_right_partial.bit 这是 shift_right 模块的部分位文件。</li><li>pblock_count_count_up_partial.bit 这是count_up 模块的部分位文件。</li><li>pblock_shift_shift_right_partial_clear.bit 这是仅用于 UltraScale 器件的 shift_right 模块的清除位文件。</li><li>pblock_count_count_up_partial_clear.bit 这是仅用于 UltraScale 器件的 count_up 模块的清除位文件。</li></ul><ol><li><p>为第二个配置生成完整和部分比特流，再次将生成的比特文件保存在适当的文件夹中。</p> <pre class="line-numbers language-none"><code class="language-none">open_checkpoint Implement&#x2F;Config_shift_left_count_down_import&#x2F;top_route_design.dcpwrite_bitstream -force -file Bitstreams&#x2F;second&#x2F;Config_LeftDown.bitclose_project<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>类似地，创建了五个（或三个）比特流，这一次具有不同的基本名称。</p></li><li><p>生成带有灰色框的完整比特流，以及可重构模块的消隐比特流。消隐比特流可用于“擦除”现有配置以降低功耗。</p><blockquote><p>注意：灰盒消隐比特流与清除比特流不同。需要清除比特流来为下一个部分比特流准备全局信号掩码，确保 GSR 事件正确发生。</p></blockquote> <pre class="line-numbers language-none"><code class="language-none">open_checkpoint Checkpoint&#x2F;static_route_design.dcpupdate_design -cell inst_count -buffer_portsupdate_design -cell inst_shift -buffer_portsplace_designroute_designwrite_checkpoint -force Checkpoint&#x2F;config_grey_box.dcpwrite_bitstream -force -file Bitstreams&#x2F;config_grey_box.bitclose_project<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>基本配置比特流没有任何可重新配置分区的逻辑。此处的 update_design 命令为可重配置分区的所有输出插入恒定驱动器（接地），因此这些输出不会浮动。术语灰色框表示插入这些 LUT 的模块并非完全为空，与黑色框相反，黑框在该区域内外都有悬空网络。 place_design 和 route_design 命令确保它们被完全实现。作为有效的可重配置模块，请注意，这些实例还具有仅用于 UltraScale 设备的清除比特流。</p></li></ol><h3 id="十、部分重新配置-FPGA">十、部分重新配置 FPGA</h3><p> 没有测试板子，暂时不过这一节<br>参考：ug947-2022.1</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;UltraScale 基本 DFX 流程。目前动态可重构(Partial Reconfiguration) 已经更名为DFX(Dynamic Function eXchange, 动态功能切换)，方便软件工程师也能更容易理解这个Feature.​&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="DFX" scheme="https://naughtyrabbit.github.io/categories/DFX/"/>
    
    
    <category term="FPGA" scheme="https://naughtyrabbit.github.io/tags/FPGA/"/>
    
    <category term="DFX" scheme="https://naughtyrabbit.github.io/tags/DFX/"/>
    
    <category term="部分可重构" scheme="https://naughtyrabbit.github.io/tags/%E9%83%A8%E5%88%86%E5%8F%AF%E9%87%8D%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>FPGA_PR_1app</title>
    <link href="https://naughtyrabbit.github.io/2022/08/20/FPGA-PR-1app/"/>
    <id>https://naughtyrabbit.github.io/2022/08/20/FPGA-PR-1app/</id>
    <published>2022-08-20T03:15:36.000Z</published>
    <updated>2022-08-24T08:53:07.681Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本篇主要是部分可重构的应用，暂时搁置，看到提醒我填坑 ^_^</p></blockquote><span id="more"></span><p>  正文</p><h3 id="一、一级标题">一、一级标题</h3>]]></content>
    
    
    <summary type="html">本篇主要是部分可重构的应用，暂时搁置，看到提醒我填坑 ^_^</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>FPGA_部分可重构技术_0介绍</title>
    <link href="https://naughtyrabbit.github.io/2022/08/19/FPGA_PR_0/"/>
    <id>https://naughtyrabbit.github.io/2022/08/19/FPGA_PR_0/</id>
    <published>2022-08-19T05:27:04.000Z</published>
    <updated>2022-08-20T03:14:29.814Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本篇主要是FPGA中部分可重构技术学习笔记，第0篇。内容主要参考赛灵思官方文档ug909.ug947等，部分翻译可能存在问题，还请指正。这一部分主要为Partial Reconfiguration（PR）的介绍</p></blockquote><span id="more"></span><p>  在减少尺寸、重量、功率和成本的同时，部分可重构技术使得一些新的FPGA设计成为可能。</p><h3 id="一、专业名词">一、专业名词</h3><ol><li>自底向上综合（Bottom-Up Synthesis）<br>  在Vivado中，自底向上综合指的是脱离上下文的综合（<strong>out-of-context synthesis</strong>）.OOC综合为每个OOC模块生成一个单独的网表(或DCP)，并需要进行部分重构，以确保没有在模块边界上进行优化。在OOC综合中，顶层（或静态）逻辑与每个OOC模块的黑盒模块定义一起合成。</li><li>配置（Configuration）<br>  配置是一个完整的设计，对于每个可重构分区都有一个可重构模块。在部分重新配置FPGA项目中可能有许多配置。每个配置都会生成一个完整的BIT文件，以及为每个可重构的模块(RM)生成一个部分的BIT文件。</li><li>配置帧（Configuration Frame）<br>  配置帧是FPGA配置内存空间中最小的可寻址段。可重构的框架是由这些最低级别元素的离散数构建的。在Xilinx设备中，基本可重构帧是一个元素(CLB，RAM，DSP)宽由一个时钟区域高。这些帧中的资源数量因设备系列而异。</li><li>内部配置访问端口（Internal Configuration Access Port）<br>  内部配置访问端口（ICAP）本质上是SelectMAP接口的内部版本</li><li>媒体配置访问端口（Media Configuration Access Port）<br>  MCAP是从每个 UltraScale设备的一个特定的PCIe®块到ICAP的专用链路。在配置Xilinx PCIe IP时，可以启用此入口点。</li><li>部分可重构（Partial Reconfiguration）<br>  部分重构是通过下载部分比特流来修改操作FPGA设计中的逻辑子集</li><li>分区（Partition）<br>  分区是设计的一个逻辑部分，用户在层次边界上定义，以考虑设计重用。分区要么作为新的实现，要么从以前的实现中保留。保留的分区不仅维护相同的功能，而且还维护相同的实现</li><li>分区定义（Partition Definition）<br>  这是一个仅在项目流中使用的术语。分区定义定义了一组与模块实例（或可重构分区）关联的可重构模块。PD应用于模块的所有实例，并且不能与模块实例的子集相关联。</li><li>分区引脚（Partition Pin）<br>  分区引脚是静态逻辑和可重构逻辑之间的逻辑和物理连接。工具会自动创建、放置和管理分区引脚。</li><li>处理器配置访问端口（Processor Configuration Access Port）<br>  处理器配置访问端口(PCAP)类似于内部配置访问端口(ICAP)，是用于配置Zynq-7000 AP SoC设备的主端口。</li><li>可编程部件（Programmable Unit）<br>  在UltraScale结构中，这是重新配置所需的最小资源。PU的大小因资源类型而异。因为相邻的站点在UltraScale体系结构中共享一个路由资源（或互连贴图），所以PU是根据成对来定义的。</li><li>可重构帧（Reconfigurable Frame）<br>  可重构帧（在本指南中除“配置帧”之外的所有参考文献中）表示FPGA中最小的可重构区域。可重构帧的比特流大小取决于帧中所包含的逻辑类型。</li><li>可重构逻辑（Reconfigurable Logic）<br>  可重构逻辑是作为可重构模块的一部分的任何逻辑元素。当加载部分BIT文件时，会修改这些逻辑元素。可以重新配置逻辑组件的许多类型，如LUTs、flip-flops、块RAM和DSP块。</li><li>可重构模块（Reconfigurable Module）<br>  可重构模块(RM)是在可重构分区中实现的网络列表或HDL描述。对于一个可重构的分区，存在多个RMs。</li><li>可重构分区（Reconfigurable Partition）<br>  可重构分区(RP)是实例上设置的属性，它将实例定义为可重构。可重构分区是在其中实现不同的可重构模块的层次结构级别。Tcl命令，如opt_design,<br>place_design和route_design检测实例上的HD.RECONFIGURABLE 属性，并正确地处理它。</li><li>静态逻辑（Static Logic）<br>  静态逻辑是不属于RP的任何逻辑元素。逻辑元素永远不会部分重新配置，并且在重新配置rp时始终处于活动状态。静态逻辑也被称为顶级逻辑。</li><li>静态设计（Static Design）<br>  静态设计是设计中在部分重新配置过程中不会改变的部分。静态设计包括顶层模块和所有未定义为可重构模块的模块。静态设计采用静态逻辑和静态路由来构建</li></ol><h3 id="二、设计注意事项">二、设计注意事项</h3><ol><li>设计指南<ul><li>需要平面规划来定义每个元素类型的可重新配置区域。</li><li>自下而上/OOC 综合（创建多个网表/DCP 文件）和可重配置模块网表文件的管理是用户的责任。</li><li>已经建立了一套独特的设计规则检查 (DRC)，以帮助确保成功完成设计。</li><li>PR 设计必须考虑部分重配置的启动以及部分 BIT 文件的交付，无论是在 FPGA 内还是作为系统设计的一部分。</li><li>Vivado 设计套件包括对部分重配置控制器 IP 的支持。这种可定制的 IP 可管理任何 Xilinx 器件中部分重配置的核心任务。内核从硬件或软件接收触发器，管理握手和解耦任务，从内存位置获取部分比特流，并将它们传递给 ICAP。</li><li>可重配置分区必须包含所有引脚的超集，供为分区实现的各种可重配置模块使用。如果 RM 使用来自另一个 RM 的不同输入或输出，则生成的 RM 输入或输出可能不会连接到 RM 内部。这些工具通过在 RM 中为所有未使用的输入和输出插入一个 LUT1 缓冲区来处理此问题。输出 LUT1 绑定到一个常数值，常数的值可以由未使用的输出引脚上的 HD.PARTPIN_TIEOFF 属性控制。</li><li>对于用户复位信号，确定 RM 内部的逻辑是电平敏感还是边沿敏感。如果复位电路是边沿敏感的（因为它可能在某些 IP，如 FIFO 中），则在重新配置完成之前不应应用 RM 复位。</li></ul></li><li>设计标准<ul><li>对于 UltraScale 和 UltraScale+ 器件，可重新配置的组件类型列表更为广泛：<br><img src="https://m1.im5i.com/2022/08/20/UqDWRK.png" alt="U+系列支持PR组件"></li><li>可重新配置模块必须进行初始化，以确保重新配置后的可预测启动条件。对于 7 系列以外的所有设备，PR 完成后会自动应用 GSR。对于 7 系列设备，在满足 Pblock 要求后，可以使用 RESET_AFTER_RECONFIG Pblock 属性打开 GSR。</li><li>强烈建议使用去耦逻辑，以便在部分重配置操作期间将可重配置区域与设计的静态部分断开。</li><li>实现工具禁止跨 PR 边界进行优化。 PR 设计中的 WNS 路径通常是跨越 RP 边界的高扇出控制/复位信号。避免高扇出信号穿过 RP 边界，因为驱动器无法复制。为了使工具具有最大的优化/复制灵活性，请考虑以下几点：<ul><li>对于 RP 的输入，使穿过 RP 边界的信号成为单个扇出网络，并在扇出之前将信号寄存在 RM 内。这可以根据需要在 RM 内复制（或放在全局资源上）。</li><li>对于输出，再次使穿过 PR 边界的信号成为单个扇出网络。在扇出之前将信号注册为静态以进行复制/优化。</li></ul></li><li>对于具有多个 RP 的设计，赛灵思建议不要在两个 RP 之间建立直接连接。这包括通过异步静态逻辑（未在静态中注册）的连接。如果两个 RP 之间存在直接连接，则必须在静态时序分析中验证所有可能的配置，以确保跨这些接口满足时序要求。这可以针对完全由单个用户拥有和维护的封闭系统完成，但对于由多个用户开发不同 RM 的设计可能无法验证。在静态中添加同步端点可确保在任何配置上始终满足时序，只要实现 RM 的配置满足时序。</li></ul></li></ol><blockquote><p>  部分重配置是赛灵思器件中的一项强大功能，了解芯片和软件的功能对于该技术的成功至关重要。虽然在开发过程中必须承认和考虑权衡，但总体结果是更灵活地实现您的 FPGA 设计。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本篇主要是FPGA中部分可重构技术学习笔记，第0篇。内容主要参考赛灵思官方文档ug909.ug947等，部分翻译可能存在问题，还请指正。这一部分主要为Partial Reconfiguration（PR）的介绍&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="部分可重构" scheme="https://naughtyrabbit.github.io/categories/%E9%83%A8%E5%88%86%E5%8F%AF%E9%87%8D%E6%9E%84/"/>
    
    
    <category term="FPGA" scheme="https://naughtyrabbit.github.io/tags/FPGA/"/>
    
    <category term="部分可重构" scheme="https://naughtyrabbit.github.io/tags/%E9%83%A8%E5%88%86%E5%8F%AF%E9%87%8D%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Vitis-AI 编译使用minist解读</title>
    <link href="https://naughtyrabbit.github.io/2022/03/23/vitisai-minist/"/>
    <id>https://naughtyrabbit.github.io/2022/03/23/vitisai-minist/</id>
    <published>2022-03-23T04:27:13.000Z</published>
    <updated>2022-03-28T15:23:38.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>由于TVM框架目前未找到合适的方法部署神经网络（pytorch框架）在FPGA上，故想要单独尝试Vitis-AI编译网络流程。一下是官方的以手写数字识别的vitis-ai pytorch流的指导。记录执行过程并分析。</p></blockquote><span id="more"></span><p>  整体的flow如下图所示：<br><img src="https://s1.ax1x.com/2022/03/23/qlLOqs.png" alt="图片描述"><br>  首先利用数据集训练得到模型文件，然后用校准数据和模型共同输入到量化器中，然后编译生成的.xmodel得到可以再FPGA上运行的.xmodel文件。最后在目标FPGA平台上使用生成的.xmodel模型文件。</p><h3 id="一、训练">一、训练</h3><p>  该脚本将执行 CNN 的训练，并将训练的浮点模型另存为 ./build/float_model 文件夹中的 .pth 文件。即f_model.pth</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># folders</span><span class="token builtin class-name">export</span> <span class="token assign-left variable">BUILD</span><span class="token operator">=</span>./build<span class="token builtin class-name">export</span> <span class="token assign-left variable">LOG</span><span class="token operator">=</span><span class="token variable">$&#123;BUILD&#125;</span>/logs<span class="token function">mkdir</span> -p <span class="token variable">$&#123;LOG&#125;</span><span class="token comment"># run training</span>python -u train.py -d <span class="token variable">$&#123;BUILD&#125;</span> <span class="token operator"><span class="token file-descriptor important">2</span>></span><span class="token file-descriptor important">&amp;1</span> <span class="token operator">|</span> <span class="token function">tee</span> <span class="token variable">$&#123;LOG&#125;</span>/train.log<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="二、量化">二、量化</h3><p>  Xilinx DPU 系列 ML 加速器执行的模型和网络的参数采用整数格式，因此我们必须将经过训练的浮点检查点转换为定点整数检查点 - 此过程称为量化。<br>  量化完成后，可以在 ./build/quant_model 文件夹中找到量化模型。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># quantize &amp; export quantized model</span>python -u quantize.py -d <span class="token variable">$&#123;BUILD&#125;</span> --quant_mode calib <span class="token operator"><span class="token file-descriptor important">2</span>></span><span class="token file-descriptor important">&amp;1</span> <span class="token operator">|</span> <span class="token function">tee</span> <span class="token variable">$&#123;LOG&#125;</span>/quant_calib.logpython -u quantize.py -d <span class="token variable">$&#123;BUILD&#125;</span> --quant_mode <span class="token builtin class-name">test</span>  <span class="token operator"><span class="token file-descriptor important">2</span>></span><span class="token file-descriptor important">&amp;1</span> <span class="token operator">|</span> <span class="token function">tee</span> <span class="token variable">$&#123;LOG&#125;</span>/quant_test.log``<span class="token variable"><span class="token variable">`</span>   <span class="token operator">&amp;</span>ensp<span class="token punctuation">;</span><span class="token operator">&amp;</span>ensp<span class="token punctuation">;</span>量化模式分为量化和评估，可以在评估中看到量化对模型推理准确性的影响。事实上，不管是test还是calib模式，都会对量化的模型进行评估，唯一不同的是，calib模式会导出量化参数，而test模式会导出量化后的模型。<span class="token variable">`</span></span>`<span class="token variable"><span class="token variable">`</span> python  <span class="token comment"># export config</span>  <span class="token keyword">if</span> quant_mode <span class="token operator">==</span> <span class="token string">'calib'</span><span class="token builtin class-name">:</span>    quantizer.export_quant_config<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token keyword">if</span> quant_mode <span class="token operator">==</span> <span class="token string">'test'</span><span class="token builtin class-name">:</span>    quantizer.export_xmodel<span class="token punctuation">(</span>deploy_check<span class="token operator">=</span>False, <span class="token assign-left variable">output_dir</span><span class="token operator">=</span>quant_model<span class="token punctuation">)</span><span class="token variable">`</span></span>``  <span class="token operator">&amp;</span>ensp<span class="token punctuation">;</span><span class="token operator">&amp;</span>ensp<span class="token punctuation">;</span>然而，比较令人费解的是，两次执行改脚本的量化评估结果却不同：其次是量化之后的两次评估结果都比训练3轮的评估结果要好。可能是因为改模型网络以及输入数据比较简单。  <span class="token operator">!</span><span class="token punctuation">[</span>图片描述<span class="token punctuation">]</span><span class="token punctuation">(</span>https://s1.ax1x.com/2022/03/23/q1aAoT.png<span class="token punctuation">)</span>  ----------划重点---------------------------------------------  <span class="token operator">&amp;</span>ensp<span class="token punctuation">;</span><span class="token operator">&amp;</span>ensp<span class="token punctuation">;</span>另外，亲测pytorch1.7版本（默认镜像是1.4版本）在导入会报如下错误：<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>undefined symbol: _ZN6caffe28TypeMeta21_typeMetaDataInstanceIN3c108BFloat16EEEPKNS_6detail12TypeMetaDataEv</p><pre><code>![图片描述](https://s1.ax1x.com/2022/03/23/q16juF.png)  &amp;ensp;&amp;ensp;该Bug在vitis-ai用户指南中提到，解决方法是先导入pytorch_nndct，后导入torch。似乎没用。  &amp;ensp;&amp;ensp;按照官方的/opt/viitis_ai/scripts/replace_pytorch.sh，脚本生成新的pytorch环境我不知道为啥还会有问题，按照脚本在原来的基础上删了原来的torch以及vai_q_pytorch，用1.7的torch环境编译了vai_q_pytorch，之后可以正常使用1.7版本torch进行量化### 三、编译  &amp;ensp;&amp;ensp;编译后的模型会保存在 ./build/compiled_model 文件夹。并以目标命名。``` bash  # compile for target boardssource compile.sh zcu102 $&#123;BUILD&#125; $&#123;LOG&#125;# make target folderspython -u target.py --target zcu102 -d $&#123;BUILD&#125; 2&gt;&amp;1 | tee $&#123;LOG&#125;/target_zcu102.log</code></pre><p>  <a href="http://xn--compile-nw3kg80pt26f.sh">下面是compile.sh</a>：</p><pre><code class="language-bash">if [ $1 = zcu102 ]; then      ARCH=/opt/vitis_ai/compiler/arch/DPUCZDX8G/ZCU102/arch.json      TARGET=zcu102      echo &quot;-----------------------------------------&quot;      echo &quot;COMPILING MODEL FOR ZCU102..&quot;      echo &quot;-----------------------------------------&quot;  </code></pre><h3 id="四、导出">四、导出</h3><p>  该脚本将执行以下操作：<a href="http://target.py">target.py</a></p><ol><li>创建一个名为 ./build/target_&lt;board_name&gt; 的文件夹。</li><li>将相应的已编译模型复制到 ./build/target_&lt;board_name&gt; 文件夹。</li><li>将 Python 应用程序代码复制到 ./build/target_&lt;board_name&gt; 文件夹。</li><li>将 MNIST 测试数据集转换为 PNG 图像文件。<br>图像数由命令行参数设置，该参数默认为 10000。–num_images</li></ol><pre><code class="language-bash"># compile for target boardssource compile.sh zcu102 $&#123;BUILD&#125; $&#123;LOG&#125;# make target folderspython -u target.py --target zcu102 -d $&#123;BUILD&#125; 2&gt;&amp;1 | tee $&#123;LOG&#125;/target_zcu102.log</code></pre>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;由于TVM框架目前未找到合适的方法部署神经网络（pytorch框架）在FPGA上，故想要单独尝试Vitis-AI编译网络流程。一下是官方的以手写数字识别的vitis-ai pytorch流的指导。记录执行过程并分析。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Vitis-AI" scheme="https://naughtyrabbit.github.io/categories/Vitis-AI/"/>
    
    
    <category term="Vitis-AI" scheme="https://naughtyrabbit.github.io/tags/Vitis-AI/"/>
    
  </entry>
  
  <entry>
    <title>TVM编译模型（yolov3_tf的例子解读）</title>
    <link href="https://naughtyrabbit.github.io/2022/03/18/TVM-Cperyolov3-tf/"/>
    <id>https://naughtyrabbit.github.io/2022/03/18/TVM-Cperyolov3-tf/</id>
    <published>2022-03-18T14:58:20.000Z</published>
    <updated>2022-03-20T14:54:06.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本篇主要记录一下TVM编译yolov3_tf模型的例子，FPGA开发板：zcu102</p></blockquote><span id="more"></span><h3 id="一、主机前置环境安装">一、主机前置环境安装</h3><p>  即setup_custom_yolov3.sh这个脚本，下面是详细内容，部分文件以及git仓库是我预先下载好的，以cp取代下载。下面的脚本主要就是：下载了yolov3_coco.tar.gz（即checkpoint文件），解压至checkpoint文件夹。然后利用convert_weight.py将相关权重文件转换为pb格式。使用freeze_graph.py将模型文件和权重数据整合在一起并去除无关的op。最后将整合的tf模型转换为ONNX格式（如代码块后的图所示）</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">. $VAI_ROOT&#x2F;conda&#x2F;etc&#x2F;profile.d&#x2F;conda.sh  conda activate vitis-ai-tensorflow&#x2F;opt&#x2F;vitis_ai&#x2F;conda&#x2F;envs&#x2F;vitis-ai-tensorflow&#x2F;bin&#x2F;python3.6 -m pip install --upgrade pip# 加了个换源操作，方便后面pip安装pip config set global.index-url https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simplepip install pydot&#x3D;&#x3D;1.4.1if [ ! -d &quot;&#x2F;tmp&#x2F;tensorflow-yolov3&quot; ]; then    cp -rf tensorflow-yolov3 &#x2F;tmp&#x2F;    cp yolov3_coco.tar.gz &#x2F;tmp&#x2F;    cd &#x2F;tmp&#x2F;    # git clone https:&#x2F;&#x2F;github.com&#x2F;YunYang1994&#x2F;tensorflow-yolov3     # git clone https:&#x2F;&#x2F;gitee.com&#x2F;mirrors_YunYang1994&#x2F;tensorflow-yolov3    cd tensorflow-yolov3    pip install easydict --user     cd checkpoint     # wget https:&#x2F;&#x2F;github.com&#x2F;YunYang1994&#x2F;tensorflow-yolov3&#x2F;releases&#x2F;download&#x2F;v1.0&#x2F;yolov3_coco.tar.gz     #wget https:&#x2F;&#x2F;a.y8j5.top&#x2F;s&#x2F;A58q3fK     #mv A58q3fK yolov3_coco.tar.gz    cp &#x2F;tmp&#x2F;yolov3_coco.tar.gz .    tar -xvf yolov3_coco.tar.gz    cd ..     python convert_weight.py    python freeze_graph.py    sed -i &#39;s&#x2F;.\&#x2F;&#x2F;\&#x2F;tmp\&#x2F;tensorflow-yolov3\&#x2F;&#x2F;&#39; .&#x2F;core&#x2F;config.py    # CONVERT TENSORFLOW MODEL TO ONNX    pip install numpy&#x3D;&#x3D;1.16.6 --user    pip install onnx --user     # cd &quot;$&#123;TVM_VAI_HOME&#125;&quot;&#x2F;tensorflow-yolov3    # git clone https:&#x2F;&#x2F;github.com&#x2F;onnx&#x2F;tensorflow-onnx.git    cd tensorflow-onnx &amp;&amp; python setup.py install --user &amp;&amp; cd ..    python3 -m tf2onnx.convert --input .&#x2F;yolov3_coco.pb --inputs input&#x2F;input_data:0[1,320,320,3] --outputs pred_sbbox&#x2F;concat_2:0 --output tf_yolov3_converted.onnxfi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://s1.ax1x.com/2022/03/20/qVLwJ1.png" alt="图片描述"></p><h3 id="二、编译模型">二、编译模型</h3><p>  模型的编译部分其实和之前的mxnet的编译类似，相同的地方不在重复。<a href="https://github.com/Xilinx/Vitis-AI/blob/master/external/tvm/examples/external_yolov3_tutorial.ipynb">https://github.com/Xilinx/Vitis-AI/blob/master/external/tvm/examples/external_yolov3_tutorial.ipynb</a>  官方的jupyter book有详尽的步骤，但是在jupyter上容易达成kernel died。因此，转换为一个python脚本在本地命令行执行（内存占用极大）。下面的各个代码块即是完整的py脚本，连起来可以直接运行。</p><h4 id="1-import">1. import</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token triple-quoted-string string">"""-------------------------------------------------Import packages-------------------------------------------------"""</span><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">import</span> os<span class="token punctuation">,</span> sys<span class="token keyword">import</span> os<span class="token punctuation">.</span>path<span class="token comment"># 注意到这里导入了tf</span><span class="token keyword">import</span> tensorflow <span class="token keyword">as</span> tf<span class="token keyword">from</span> pathlib <span class="token keyword">import</span> Path<span class="token comment"># pyxir</span><span class="token keyword">import</span> pyxir<span class="token keyword">import</span> pyxir<span class="token punctuation">.</span>contrib<span class="token punctuation">.</span>target<span class="token punctuation">.</span>DPUCADF8H<span class="token comment"># tvm, relay</span><span class="token keyword">import</span> tvm<span class="token keyword">from</span> tvm <span class="token keyword">import</span> te<span class="token keyword">from</span> tvm <span class="token keyword">import</span> contrib<span class="token keyword">import</span> tvm<span class="token punctuation">.</span>relay <span class="token keyword">as</span> relay<span class="token comment"># BYOC</span><span class="token keyword">from</span> tvm<span class="token punctuation">.</span>relay <span class="token keyword">import</span> transform<span class="token keyword">from</span> tvm<span class="token punctuation">.</span>contrib <span class="token keyword">import</span> utils<span class="token punctuation">,</span> graph_executor<span class="token keyword">from</span> tvm<span class="token punctuation">.</span>contrib<span class="token punctuation">.</span>target <span class="token keyword">import</span> vitis_ai<span class="token keyword">from</span> tvm<span class="token punctuation">.</span>relay<span class="token punctuation">.</span>build_module <span class="token keyword">import</span> bind_params_by_name<span class="token keyword">from</span> tvm<span class="token punctuation">.</span>relay<span class="token punctuation">.</span>op<span class="token punctuation">.</span>contrib<span class="token punctuation">.</span>vitis_ai <span class="token keyword">import</span> annotation<span class="token comment"># Tensorflow utility functions</span><span class="token keyword">import</span> tvm<span class="token punctuation">.</span>relay<span class="token punctuation">.</span>testing<span class="token punctuation">.</span>tf <span class="token keyword">as</span> tf_testing<span class="token keyword">from</span> tvm<span class="token punctuation">.</span>contrib<span class="token punctuation">.</span>download <span class="token keyword">import</span> download_testdata<span class="token keyword">from</span> tvm<span class="token punctuation">.</span>relay<span class="token punctuation">.</span>op<span class="token punctuation">.</span>contrib<span class="token punctuation">.</span>vitis_ai <span class="token keyword">import</span> partition_for_vitis_ai<span class="token keyword">import</span> cv2<span class="token keyword">try</span><span class="token punctuation">:</span>    tf_compat_v1 <span class="token operator">=</span> tf<span class="token punctuation">.</span>compat<span class="token punctuation">.</span>v1<span class="token keyword">except</span> ImportError<span class="token punctuation">:</span>    tf_compat_v1 <span class="token operator">=</span> tf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-yolov3相关预处理函数">2. yolov3相关预处理函数</h4><p>  这部分其实在编译模型阶段没有很重要，甚至可以不需要，只是在编译生成模型的时候需要得到mod, params = relay.frontend.from_onnx(onnx_model, shape_dict)中的shape_dict，这个步骤在知道网络输入格式后甚至可以直接设置为指定的，比如yolo+csl中[1024*1024].</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>Define preprocessing functions定义了一些有关yolov3_tf模型的预处理函数<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token triple-quoted-string string">"""def preprocessing(image):    image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB).astype(np.float32)    ih, iw    = (320,320)    h,  w, _  = image.shape    scale = min(iw/w, ih/h)    nw, nh  = int(scale * w), int(scale * h)    image_resized = cv2.resize(image, (nw, nh))    image_padded = np.full(shape=[ih, iw, 3], fill_value=128.0)    dw, dh = (iw - nw) // 2, (ih-nh) // 2    image_padded[dh:nh+dh, dw:nw+dw, :] = image_resized    image_padded = image_padded / 255.    return image_padded   def transform_image(image):    image = np.array(image)[np.newaxis, :]    return image```  #### 3. 准备输入，声明DPU目标  &amp;ensp;&amp;ensp;这里的input_name可以在 https://netron.app/ 网站上打开ONNX模型查看，如图（yolov5+csl的转ONNX模型）：![图片描述](https://s1.ax1x.com/2022/03/20/qe2ne0.png)  ```  python  """</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>Prepare <span class="token builtin">input</span> <span class="token keyword">and</span> specify the Vitis DPU target<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token string">""</span>"<span class="token keyword">from</span> PIL <span class="token keyword">import</span> Imageimg_path <span class="token operator">=</span> <span class="token string">"/tmp/tensorflow-yolov3/docs/images/road.jpeg"</span>original_image <span class="token operator">=</span> cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span>img_path<span class="token punctuation">)</span>image <span class="token operator">=</span> preprocessing<span class="token punctuation">(</span>original_image<span class="token punctuation">)</span> image <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>image<span class="token punctuation">)</span><span class="token punctuation">[</span>np<span class="token punctuation">.</span>newaxis<span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token comment"># 这里的image.shape是[1, 320, 320, 3]和onnx打开模型所观察到的一致</span>v_target_value <span class="token operator">=</span> <span class="token string">"DPUCZDX8G-zcu102"</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Vitis Target: "</span><span class="token punctuation">,</span> v_target_value<span class="token punctuation">)</span>input_name     <span class="token operator">=</span> <span class="token string">'input/input_data'</span>shape_dict     <span class="token operator">=</span> <span class="token punctuation">&#123;</span>input_name<span class="token punctuation">:</span> image<span class="token punctuation">.</span>shape<span class="token punctuation">&#125;</span>postprocessing <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>vitis_target   <span class="token operator">=</span> v_target_valuetvm_target     <span class="token operator">=</span> <span class="token string">'llvm'</span>lib_kwargs     <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-导入模型">4. 导入模型</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token triple-quoted-string string">"""-------------------------------------------------Import the model to TVM-------------------------------------------------"""</span>framework_value <span class="token operator">=</span> <span class="token string">"ONNX"</span><span class="token keyword">print</span> <span class="token punctuation">(</span><span class="token string">"Framework: "</span><span class="token punctuation">,</span> framework_value<span class="token punctuation">)</span><span class="token keyword">if</span> framework_value <span class="token operator">==</span> <span class="token string">"TF"</span><span class="token punctuation">:</span>    model_path <span class="token operator">=</span> <span class="token string">"/tmp/tensorflow-yolov3/yolov3_coco.pb"</span>    <span class="token keyword">with</span> tf_compat_v1<span class="token punctuation">.</span>gfile<span class="token punctuation">.</span>GFile<span class="token punctuation">(</span>model_path<span class="token punctuation">,</span> <span class="token string">"rb"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>        graph_def <span class="token operator">=</span> tf_compat_v1<span class="token punctuation">.</span>GraphDef<span class="token punctuation">(</span><span class="token punctuation">)</span>        graph_def<span class="token punctuation">.</span>ParseFromString<span class="token punctuation">(</span>f<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        graph <span class="token operator">=</span> tf<span class="token punctuation">.</span>import_graph_def<span class="token punctuation">(</span>graph_def<span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">""</span><span class="token punctuation">)</span>        <span class="token comment"># Call the utility to import the graph definition into default graph.</span>        graph_def <span class="token operator">=</span> tf_testing<span class="token punctuation">.</span>ProcessGraphDefParam<span class="token punctuation">(</span>graph_def<span class="token punctuation">)</span>        <span class="token comment"># Add shapes to the graph.</span>        <span class="token keyword">with</span> tf_compat_v1<span class="token punctuation">.</span>Session<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">as</span> sess<span class="token punctuation">:</span>            graph_def <span class="token operator">=</span> tf_testing<span class="token punctuation">.</span>AddShapesToGraphDef<span class="token punctuation">(</span>sess<span class="token punctuation">,</span> <span class="token string">"pred_sbbox/concat_2"</span><span class="token punctuation">)</span>    mod<span class="token punctuation">,</span> params <span class="token operator">=</span> relay<span class="token punctuation">.</span>frontend<span class="token punctuation">.</span>from_tensorflow<span class="token punctuation">(</span>graph_def<span class="token punctuation">,</span> shape<span class="token operator">=</span>shape_dict<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Tensorflow protobuf imported to relay frontend."</span><span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>    <span class="token keyword">import</span> onnx    input_name     <span class="token operator">=</span> <span class="token string">'input/input_data:0'</span>    shape_dict     <span class="token operator">=</span> <span class="token punctuation">&#123;</span>input_name<span class="token punctuation">:</span> image<span class="token punctuation">.</span>shape<span class="token punctuation">&#125;</span>    model_path <span class="token operator">=</span> <span class="token string">"/tmp/tensorflow-yolov3/tf_yolov3_converted.onnx"</span>    onnx_model <span class="token operator">=</span> onnx<span class="token punctuation">.</span>load<span class="token punctuation">(</span>model_path<span class="token punctuation">)</span>    mod<span class="token punctuation">,</span> params <span class="token operator">=</span> relay<span class="token punctuation">.</span>frontend<span class="token punctuation">.</span>from_onnx<span class="token punctuation">(</span>onnx_model<span class="token punctuation">,</span> shape_dict<span class="token punctuation">)</span>```  <span class="token comment">#### 5. Partitioning the model </span>```  python  <span class="token triple-quoted-string string">"""-------------------------------------------------Partitioning the model-------------------------------------------------"""</span>mod <span class="token operator">=</span> partition_for_vitis_ai<span class="token punctuation">(</span>mod<span class="token punctuation">,</span> params<span class="token punctuation">,</span> dpu<span class="token operator">=</span>vitis_target<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="6-Build-the-partitioned-TVM-module">6. Build the partitioned TVM module</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token triple-quoted-string string">"""-------------------------------------------------Build the partitioned TVM module-------------------------------------------------"""</span>export_rt_mod_file <span class="token operator">=</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>os<span class="token punctuation">.</span>getcwd<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'vitis_ai.rtmod'</span><span class="token punctuation">)</span>build_options <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">'dpu'</span><span class="token punctuation">:</span> vitis_target<span class="token punctuation">,</span><span class="token string">'export_runtime_module'</span><span class="token punctuation">:</span> export_rt_mod_file<span class="token punctuation">&#125;</span><span class="token keyword">with</span> tvm<span class="token punctuation">.</span>transform<span class="token punctuation">.</span>PassContext<span class="token punctuation">(</span>opt_level<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> config<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token string">'relay.ext.vitis_ai.options'</span><span class="token punctuation">:</span> build_options<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">:</span>lib <span class="token operator">=</span> relay<span class="token punctuation">.</span>build<span class="token punctuation">(</span>mod<span class="token punctuation">,</span> tvm_target<span class="token punctuation">,</span> params<span class="token operator">=</span>params<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="7-量化模型">7. 量化模型</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token triple-quoted-string string">"""-------------------------------------------------Quantize the model-------------------------------------------------"""</span>QUANT_DIR <span class="token operator">=</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token string">"/opt/tvm-vai"</span><span class="token punctuation">,</span> <span class="token string">"CK-TOOLS/dataset-imagenet-ilsvrc2012-val-min/"</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">inputs_func</span><span class="token punctuation">(</span>img_files<span class="token punctuation">)</span><span class="token punctuation">:</span>inputs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">for</span> img_path <span class="token keyword">in</span> img_files<span class="token punctuation">:</span>    image <span class="token operator">=</span> cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span>img_path<span class="token punctuation">)</span>    image <span class="token operator">=</span> cv2<span class="token punctuation">.</span>cvtColor<span class="token punctuation">(</span>image<span class="token punctuation">,</span> cv2<span class="token punctuation">.</span>COLOR_BGR2RGB<span class="token punctuation">)</span>    image <span class="token operator">=</span> preprocessing<span class="token punctuation">(</span>image<span class="token punctuation">)</span>    inputs<span class="token punctuation">.</span>append<span class="token punctuation">(</span>transform_image<span class="token punctuation">(</span>image<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">return</span> inputs<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Create InferenceSession for OTF Quantization"</span><span class="token punctuation">)</span>module <span class="token operator">=</span> graph_executor<span class="token punctuation">.</span>GraphModule<span class="token punctuation">(</span>lib<span class="token punctuation">[</span><span class="token string">"default"</span><span class="token punctuation">]</span><span class="token punctuation">(</span>tvm<span class="token punctuation">.</span>cpu<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># px_quant_size = int(os.environ['PX_QUANT_SIZE']) \</span><span class="token comment">#     if 'PX_QUANT_SIZE' in os.environ else 128</span>px_quant_size <span class="token operator">=</span> <span class="token number">128</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Start OTF Quantization on first &#123;&#125; images"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>px_quant_size<span class="token punctuation">)</span><span class="token punctuation">)</span>quant_files <span class="token operator">=</span> <span class="token punctuation">[</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>QUANT_DIR<span class="token punctuation">,</span> f<span class="token punctuation">)</span> <span class="token keyword">for</span> f <span class="token keyword">in</span> os<span class="token punctuation">.</span>listdir<span class="token punctuation">(</span>QUANT_DIR<span class="token punctuation">)</span>         <span class="token keyword">if</span> f<span class="token punctuation">.</span>endswith<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">'JPEG'</span><span class="token punctuation">,</span> <span class="token string">'jpg'</span><span class="token punctuation">,</span> <span class="token string">'png'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">:</span>px_quant_size<span class="token punctuation">]</span>quant_images <span class="token operator">=</span> inputs_func<span class="token punctuation">(</span>quant_files<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Loaded &#123;&#125; inputs successfully.'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>quant_images<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>px_quant_size<span class="token punctuation">)</span><span class="token punctuation">:</span>module<span class="token punctuation">.</span>set_input<span class="token punctuation">(</span>input_name<span class="token punctuation">,</span> quant_images<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>module<span class="token punctuation">.</span>run<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="8-导出模型">8. 导出模型</h4><pre><code class="language-python">&quot;&quot;&quot;-------------------------------------------------Export and run on a Zynq edge device-------------------------------------------------&quot;&quot;&quot;if vitis_target.startswith('DPUCZDX8G'):# Export runtime moduletemp = utils.tempdir()lib.export_library(temp.relpath(&quot;tvm_lib.so&quot;))# Build and export lib for aarch64 targettvm_target = tvm.target.arm_cpu('ultra96')lib_kwargs = &#123;    'fcompile': contrib.cc.create_shared,    'cc': &quot;/usr/aarch64-linux-gnu/bin/ld&quot;&#125;build_options = &#123;    'load_runtime_module': export_rt_mod_file&#125;with tvm.transform.PassContext(opt_level=3, config=&#123;'relay.ext.vitis_ai.options': build_options&#125;):    lib_dpuczdx8g = relay.build(mod, tvm_target, params=params)lib_dpuczdx8g.export_library('tvm_dpu_cpu.so', **lib_kwargs)else:lib.export_library('tvm_dpu_cpu.so')print(&quot;Finished storing the compiled model as tvm_dpu_cpu.so&quot;)print(&quot;Finished OTF Quantization&quot;)</code></pre><h3 id="三、推理">三、推理</h3><p>  推理过程主要包括一下步骤：</p><pre><code>注意框架参数选择TF/ONNX（默认TF）图像预处理 =&gt;加载模型 =&gt; model.run后处理（包括bounding box的nms以及图片写回等）</code></pre><p>  下图是在zcu102上的测试运行结果<br><img src="https://s1.ax1x.com/2022/03/20/qefL7t.png" alt="图片描述"></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本篇主要记录一下TVM编译yolov3_tf模型的例子，FPGA开发板：zcu102&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="TVM" scheme="https://naughtyrabbit.github.io/categories/TVM/"/>
    
    
    <category term="TVM" scheme="https://naughtyrabbit.github.io/tags/TVM/"/>
    
  </entry>
  
  <entry>
    <title>TVM编译模型（tf的例子解读）</title>
    <link href="https://naughtyrabbit.github.io/2022/03/14/TVM-CperModExa-tf/"/>
    <id>https://naughtyrabbit.github.io/2022/03/14/TVM-CperModExa-tf/</id>
    <published>2022-03-14T14:15:19.000Z</published>
    <updated>2022-03-21T04:16:30.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本篇主要记录一下TVM编译一个使用tf框架模型的例子，FPGA开发板：zcu102</p></blockquote><span id="more"></span><h3 id="一、流程记录">一、流程记录</h3><p>  需要注意的是，显然（我就不知道） <a href="https://tvm.apache.org/docs/how_to/deploy/vitis_ai.html">https://tvm.apache.org/docs/how_to/deploy/vitis_ai.html</a>   TVM官方这里给的流程，不是完整脚本，只是一个介绍，完整Py脚本可以在编译模型的相关网页最下面下载得到。<br><img src="https://s1.ax1x.com/2022/03/14/bXxDqU.png" alt="图片描述"><br>  过程跟着 <a href="https://github.com/Xilinx/Vitis-AI/blob/1.4/external/tvm/docs/compiling_a_model.md">https://github.com/Xilinx/Vitis-AI/blob/1.4/external/tvm/docs/compiling_a_model.md</a>  这个走。</p><ol><li>运行容器镜像：./docker_run.sh tvm.ci_vai_1x</li><li>进入tf虚拟环境</li><li>进入example文件夹</li><li>编译生成对应目标的文件 python3 compile_mxnet_resnet_18.py “DPUCZDX8G-zcu102”<br>最后一个参数指<strong>DPU target ID</strong> 参照： <a href="https://github.com/Xilinx/Vitis-AI/blob/1.4/external/tvm/README.md#dpu-targets">https://github.com/Xilinx/Vitis-AI/blob/1.4/external/tvm/README.md#dpu-targets</a><br>然后就生成一个如图的 .so 文件，在FPGA上调用。<br><img src="https://s1.ax1x.com/2022/03/14/bXvMBF.png" alt="图片描述"></li></ol><h3 id="二、编译脚本解析">二、编译脚本解析</h3><p>  显然，自己的网络部署不能用同样的脚本，因此对官方的编译脚本作分析，以实现客制化部署自己的网络。下面是具体的分析（代码段部分是完整的compile_mxnet_resnet_18.py，注释部分是自加的），也是本文重点。</p><h4 id="1-imports">1. imports</h4><p>  需要注意的是，脚本中导入<strong>pyxir</strong>等模块并未直接使用（在该脚本代码中体现），但是相关模块的导入以及<strong>DPU</strong>目标的声明仍是不可或缺的，否则在执行时会出错。</p><pre><code class="language-python">import osimport sysimport numpy as npimport cv2import timefrom typing import Listfrom pathlib import Path# pyxir是tvm和vitis-ai集成的接口，但是这个脚本中似乎只是引入，没有使用该模块？# 然而教程中特意强调了必须引入该模块# pycharm中显示为灰色，建议尝试注释后是否能够正确生成.so文件# 不能，必须加，注释掉会其实缺少文件import pyxir# 这句同理也是灰色import pyxir.contrib.target.DPUCADF8Himport loggingimport tvmfrom tvm import contribimport tvm.relay as relayfrom tvm.relay import transformfrom tvm.contrib import utils, graph_executor as graph_runtime# 这句也是灰色from tvm.contrib.target import vitis_aifrom tvm.relay.build_module import bind_params_by_namefrom tvm.relay.op.contrib.vitis_ai import partition_for_vitis_ai</code></pre><h4 id="2-添加路径">2. 添加路径</h4><p>  在安装TVM的过程中，会把tvm-vai的路径写入环境变量（容器内），在此处获取到。相关文件比如/opt/tvm-vai相关文件都是容器内的，不在宿主环境。</p><pre><code class="language-python">FILE_DIR   = os.path.dirname(os.path.abspath(__file__))# 使用 os.getenv() 函数获取环境变量TVM_VAI_HOME   = os.getenv('TVM_VAI_HOME')QUANT_DIR = os.path.join(TVM_VAI_HOME, 'CK-TOOLS/dataset-imagenet-ilsvrc2012-val-min/')if not os.path.exists(QUANT_DIR):    raise ValueError(&quot;Could not find directory &quot;                     &quot;~/CK-TOOLS/dataset-imagenet-ilsvrc2012-val-min/.&quot;                     &quot; Please install using following commands before&quot;                     &quot; running this example: \n&quot;                     &quot; $ python3 -m ck pull repo:ck-env\n&quot;                     &quot; $ python3 -m ck install package:imagenet-2012-val-min\n&quot;                     &quot; $ cp -r $HOME/CK-TOOLS $TVM_VAI_HOME&quot;)</code></pre><p><img src="https://s1.ax1x.com/2022/03/16/qSMzK1.png" alt="图片描述"></p><h4 id="3-下载模型">3. 下载模型</h4><pre><code class="language-python">####################################################################### Download Resnet18 model from Gluon Model Zoo# ---------------------------------------------# In this section, we download a pretrained imagenet model and classify an image.###############################################################################from tvm.contrib.download import download_testdatafrom mxnet.gluon.model_zoo.vision import get_modelfrom PIL import Image#from matplotlib import pyplot as plt# 在线下载模型，存储至block# mxnet下api可参考：https://mxnet.apache.org/versions/1.7.0/api/python/docs/api/gluon/model_zoo/index.html#mxnet.gluon.model_zoo.vision.get_modelblock = get_model('resnet18_v1', pretrained=True)# 这个网址是一张猫的图片，不科学上网可能会获取超时，可以改成下面的# img_url = 'https://github.com/dmlc/mxnet.js/blob/master/data/cat.png?raw=true'img_url = 'https://s1.ax1x.com/2022/03/15/bvB7Ct.png'img_name = 'cat.png'synset_url = ''.join(['https://gist.githubusercontent.com/zhreshold/',                      '4d0b62f3d01426887599d4f7ede23ee5/raw/',                      '596b27d23537e5a1b5751d2b0481ef172f58b539/',                      'imagenet1000_clsid_to_human.txt'])synset_name = 'imagenet1000_clsid_to_human.txt'# 注意这个download_testdata函数默认是不重写的，会一直使用最初的图片img_path = download_testdata(img_url, 'cat.png', module='data')synset_path = download_testdata(synset_url, synset_name, module='data')with open(synset_path) as f:    synset = eval(f.read())def transform_image(image):    image = np.array(image) - np.array([123., 117., 104.])    image /= np.array([58.395, 57.12, 57.375])    image = image.transpose((2, 0, 1))    image = image[np.newaxis, :]    return image</code></pre><p>  下载下来的模型参数保存至如图位置，赋值给block<br><img src="https://s1.ax1x.com/2022/03/16/qSwTNd.png" alt="图片描述"><br>  下载下来的图片以及txt保存至如图位置<br><img src="https://s1.ax1x.com/2022/03/16/qSBcy6.png" alt="图片描述"><br>  内容如下<br><img src="https://s1.ax1x.com/2022/03/16/qSD23n.png" alt="图片描述"></p><h4 id="4-模型设置">4. 模型设置</h4><pre><code class="language-python">################################################################################ MODEL SETTINGS## Parameter settings for compiling a model using tvm-vai flow# quant_dir      : path to images for quantization# dpu_target         : hardware accelerator to run the compiled model#                      options: 'DPUCADF8H',  'DPUCZDX8G-zcu104', 'DPUCZDX8G-zcu102'# tvm_target     :# lib_kwargs     : ################################################################################ 检查 python3 compile_mxnet_resnet_18.py &quot;DPUCZDX8G-zcu102&quot; 这句命令是否带参数if len(sys.argv) &lt; 2:    raise ValueError(&quot;No DPU target specified. Please run with 'python3 compile_mxnet_resnet_18.py `DPU_TARGET`'&quot;\                     &quot; DPU_TARGET options: 'DPUCADF8H', 'DPUCAHX8H-u50lv', 'DPUCAHX8H-u50lv_dwc', 'DPUCAHX8H-u55c_dwc', 'DPUCZDX8G-zcu104', 'DPUCZDX8G-zcu102'&quot;)input_name  = 'data'# 原图(cat)shape是256*256# imagenet的图片是96x96# input_shape是模型输入的shape# 测试图片经过预处理之后会转成这个shapeinput_shape = (1,3,224,224)shape_dict  = &#123;input_name:input_shape&#125;dpu_target  = str(sys.argv[1])tvm_target  = 'llvm'lib_kwargs  = &#123;&#125;</code></pre><h4 id="5-输入预处理">5. 输入预处理</h4><pre><code class="language-python">################################################################################ INPUTS FUNC## Define and inputs function which takes in an iterator value and returns a# dictionary mapping from input name to array containing dataset inputs. Note # that the input function should always return image data in NCHW layout as # all models are converted to NCHW layout internally for Vitis-AI compilation.# # This is necessary for quantizating the model for acceleration using Vitis-AI.###############################################################################def inputs_func(img_files: List[str]):    inputs = []    for img_path in img_files:        img = Image.open(img_path)        img = img.convert('RGB')        img = img.resize(input_shape[2:])               inputs.append(transform_image(img))    return inputs</code></pre><h4 id="6-Partition-and-build-the-Model">6. Partition and build the Model</h4><pre><code class="language-python">################################################################################ PARTITION &amp; BUILD# # Use TVM Module pass to annotate and partition Relay graph for Vitis-AI acceleration. Targets can be 'DPUCADF8H', 'DPUCZDX8G-zcu104', 'DPUCZDX8G-zcu102'# Afterwards build graph using standard TVM flow.############################################################################### 利用中继（relay）api加载模型mod, params = relay.frontend.from_mxnet(block, shape_dict)# 得到（vitis_ai.rtmod）？大概？在python命令行中复现到这一句时报错# invalid pointermod = partition_for_vitis_ai(mod, params, dpu=dpu_target)export_rt_mod_file = os.path.join(os.getcwd(), 'vitis_ai.rtmod')build_options = &#123;    'dpu': dpu_target,    'export_runtime_module': export_rt_mod_file&#125;# The partitioned model is passed to the TVM compiler to generate the runtime libraries for the TVM Runtime.# 为目标编译运行时库with tvm.transform.PassContext(opt_level=3, config=&#123;'relay.ext.vitis_ai.options': build_options&#125;):   lib = relay.build(mod, tvm_target, params=params)</code></pre><h4 id="7-对模型量化">7. 对模型量化</h4><p>  <s>这一部分，不是很理解，所产生的<strong>quant_images</strong>在这一部分最后一步输入给了InferenceSession,但是对InferenceSession在下一部分的导出中没有起到作用，然后在最后的最后，把这个InferenceSession给删了。但是尝试将这一段以及最后一句del InferenceSession注释之后能产生.so文件（大小和之前不同），但是上板子运行调用报错。</s><br>  这一部分第一句InferenceSession = graph_runtime.GraphModule(lib<a href="tvm.cpu()">&quot;default&quot;</a>)，即是加载模型到InferenceSession.然后最后一步InferenceSession.run()，即是对模型进行量化。这里<strong>lib</strong>也是由上一步最后一句由relay.build产生。<br>  下载下面是待量化的图片的位置<br><img src="https://s1.ax1x.com/2022/03/17/q9R6XQ.png" alt="图片描述"><br><img src="https://s1.ax1x.com/2022/03/17/q9RBff.png" alt="图片描述"></p><pre><code class="language-python">############################################################## Quantization using first N inputs## ## Usually, to be able to accelerate inference of Neural ## Network models with Vitis-AI DPU accelerators, those models ## need to quantized upfront. In the TVM Vitis AI ## flow we make use of On-The-Fly (OTF) Quantization ## to remove this additional preprocessing step. In this flow,## one doesn't need to quantize his/her model upfront but can ## make use of the typical inference execution calls ## (InferenceSession.run) to quantize the model on-the-fly ## using the first N inputs. This will set up and calibrate## the Vitis-AI DPU and from that point onwards inference ## will be accelerated for all next inputs.## Set the number of inputs used for quantization to e.g. 8 ## using the PX_QUANT_SIZE environment variable if you want## to quantize on fewer inputs. The default is 128.############################################################print(&quot;Create InferenceSession for OTF Quantization&quot;)# 详见：https://github.com/apache/tvm/blob/main/python/tvm/contrib/graph_executor.py line:114InferenceSession = graph_runtime.GraphModule(lib[&quot;default&quot;](tvm.cpu()))px_quant_size = int(os.environ['PX_QUANT_SIZE']) \    if 'PX_QUANT_SIZE' in os.environ else 128print(&quot;Start OTF Quantization on first &#123;&#125; images&quot;.format(px_quant_size))# 这里只取了前128张图片，根据上面注释的说法，相当于 first N inputs# 之后的输入也会自动加速quant_files = [os.path.join(QUANT_DIR, f) for f in os.listdir(QUANT_DIR)             if f.endswith(('JPEG', 'jpg', 'png'))][:px_quant_size]#quant_images = inputs_func(quant_files)print('Loaded &#123;&#125; inputs successfully.'.format(len(quant_images)))for i in range(px_quant_size):    InferenceSession.set_input(input_name, quant_images[i])     # print(&quot;running&quot;)     # 执行量化，过程耗时耗内存    InferenceSession.run()print(&quot;Finished OTF Quantization&quot;)</code></pre><p>  下图是整个<strong>inputs_func</strong>函数的功能（以第一张图片为例），注意此部分代码块不是原脚本中顺序，为了方便理解</p><pre><code class="language-python"># 获取原始图片quant_images = inputs_func(quant_files) ====&gt;进入inputs_func():def inputs_func(img_files: List[str]):    inputs = []    for img_path in img_files:        # 以第一个图片为例 size(500, 375);title(0, 0, 500, 375);model = 'RGB'        img = Image.open(img_path)        img = img.convert('RGB')        # &lt;PIL.Image.Image image mode=RGB size=224x224 at 0x1FEF70F0D68&gt;        img = img.resize(input_shape[2:])               inputs.append(transform_image(img))     ====&gt;进入transform_image()):    return inputsdef transform_image(image):    # image : ndarray:(224, 224, 3) [[[ 54.  70.  85.],  [ 56.  72.  87.],  [ 58.  74.  89.],  ...,    # size : 150528 = 224*224*3    image = np.array(image) - np.array([123., 117., 104.])    # image : ndarray:(224, 224, 3) [[[0.92473671 1.2254902  1.48148148],  [0.95898621 1.2605042  1.51633987],  [0.99323572 1.29551821 1.55119826],  ...,    image /= np.array([58.395, 57.12, 57.375])    # image : ndarray:(3, 224, 224) [[[0.92473671 0.95898621 0.99323572 ... 1.13023375 1.09598425 1.06173474],  [0.95898621 0.97611097 0.97611097 ...    image = image.transpose((2, 0, 1))    # image : ndarray:(1, 3, 224, 224) [[[[0.92473671 0.95898621 0.99323572 ... 1.13023375 1.09598425 1.06173474],  [0.95898621 0.97611097 0.97611097 ...    image = image[np.newaxis, :]    return image</code></pre><h4 id="8-导出库">8. 导出库</h4><p>  对于DPUZDX8G目标板需要根据aarch64进行rebuild</p><pre><code class="language-python">########################################################## Export compiled model for execution ##########################################################if dpu_target.startswith('DPUCZDX8G'):    # Export runtime module    temp = utils.tempdir()    lib.export_library(temp.relpath(&quot;tvm_lib.so&quot;))    # Build and export lib for aarch64 target    tvm_target = tvm.target.arm_cpu('ultra96')    lib_kwargs = &#123;        'fcompile': contrib.cc.create_shared,        'cc': &quot;/usr/aarch64-linux-gnu/bin/ld&quot;    &#125;    build_options = &#123;        'load_runtime_module': export_rt_mod_file    &#125;    with tvm.transform.PassContext(opt_level=3, config=&#123;'relay.ext.vitis_ai.options': build_options&#125;):        lib_dpuczdx8g = relay.build(mod, tvm_target, params=params)    lib_dpuczdx8g.export_library('tvm_dpu_cpu.so', **lib_kwargs)else:    lib.export_library('tvm_dpu_cpu.so')print(&quot;Finished storing compiled model as tvm_dpu_cpu.so&quot;)del InferenceSession</code></pre>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本篇主要记录一下TVM编译一个使用tf框架模型的例子，FPGA开发板：zcu102&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="TVM" scheme="https://naughtyrabbit.github.io/categories/TVM/"/>
    
    
    <category term="TVM" scheme="https://naughtyrabbit.github.io/tags/TVM/"/>
    
  </entry>
  
  <entry>
    <title>TVM环境搭建</title>
    <link href="https://naughtyrabbit.github.io/2022/03/12/TVM-setup/"/>
    <id>https://naughtyrabbit.github.io/2022/03/12/TVM-setup/</id>
    <published>2022-03-12T14:31:17.000Z</published>
    <updated>2022-03-13T05:47:56.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本篇主要记录一下TVM环境搭建过程，FPGA开发板：zcu102</p></blockquote><span id="more"></span><h3 id="一、主机环境搭建">一、主机环境搭建</h3><p>  大部分的流程跟着官方文档：<a href="https://tvm.apache.org/docs/how_to/deploy/vitis_ai.html%EF%BC%8C">https://tvm.apache.org/docs/how_to/deploy/vitis_ai.html，</a> 这篇的内容是利用Vitis-AI环境去搭建安装VTM。这里重点记录一些需要注意的地方。</p><h4 id="1-docker相关">1.docker相关</h4><h5 id="1-1-docker容器拉取">1.1 docker容器拉取</h5><p>  利用<strong>docker</strong>去<strong>pull</strong>官方的<strong>container</strong>(容器)的时候可以换源来加速（由于要下载的内容较多，科学上网中途可能因为安全问题被断开连接）。daocloud的加速教程：<a href="http://guide.daocloud.io/dcs/daocloud-9153151.html#docker-toolbox">http://guide.daocloud.io/dcs/daocloud-9153151.html#docker-toolbox</a></p><h5 id="1-2-GPG-ERROR">1.2 GPG ERROR</h5><pre class="line-numbers language-none"><code class="language-none">GPG error: https:&#x2F;&#x2F;apt.kitware.com&#x2F;ubuntu bionic InRelease:The following signatures couldn&#39;t be verified because the public kev is not available: NO_PUBKEY 6AF7F99730B3F0A4&#96;&#96;&#96;  &amp;ensp;&amp;ensp;按照网上教程直接在命令行输入：RUN apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 6AF7F09730B3F0A4  会提示**failed**。应该在**Dockerfile.demo_vitis_ai**文件中作如图修改，另外注意在脚本执行到这一句的时候不要用科学上网，之后获取ubuntu的archrive的时候科学上网会快一点，在此处会直接导致脚本执行失败。![图片描述](https:&#x2F;&#x2F;s1.ax1x.com&#x2F;2022&#x2F;03&#x2F;12&#x2F;bH5BDO.png)  ##### 1.3 python版本错误&#96;&#96;&#96;  This script does not work on Python 3.6 The minimum supported Python version is 3.7. Please use https:&#x2F;&#x2F;bootstrap.pypa.io&#x2F;pip&#x2F;3.6&#x2F;get-pip.py instead.The command &#39;&#x2F;bin&#x2F;sh -c bash &#x2F;install&#x2F;ubuntu_install_python.sh&#39; returned a non-zero code: 1  解决：修改tvm&#x2F;docker&#x2F;install&#x2F;ubuntu_install_python.sh 中https链接为错误提示链接。即：# 修改前（line:36~37）：# Install pipcd &#x2F;tmp &amp;&amp; wget -q https:&#x2F;&#x2F;bootstrap.pypa.io&#x2F;get-pip.py &amp;&amp; python3.6 get-pip.py# 修改后（line:36~37）：# Install pipcd &#x2F;tmp &amp;&amp; wget -q https:&#x2F;&#x2F;bootstrap.pypa.io&#x2F;pip&#x2F;3.6&#x2F;get-pip.py &amp;&amp; python3.6 get-pip.py&#96;&#96;&#96;  #### 2.TVM build相关  #### 2.1 cmake错误  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>CMake Error at /opt/vitis_at/conda/envs/vitis-ai-pytorch/lib/cmake/GTest/GTestTargets. cmake:103 (message):<br>The imported target &quot;GTest:: gmock&quot;references the file<br>“/opt/vitis_ai/conda/envs/vitis-at-pytorch/lib/libgmock. so”<br>but this file does not extst. Possible reasons include:<br>解决：<br>根据github上的issue：<a href="https://github.com/apache/tvm/issues/9772">https://github.com/apache/tvm/issues/9772</a><br>修改 tvm/cmake/config.cmake（Line 359）<br>ORIGINAL:set(USE_GTEST AUTO)<br>UPDATE: set(USE_GTEST OFF)</p><pre class="line-numbers language-none"><code class="language-none">#### 2.2 pytorch环境下，cmake错误&#96;&#96;&#96;  CMake Error at cmake&#x2F;modules&#x2F;contrib&#x2F;VitisAI.cmake:36 (message):  Can&#39;t build TVM with Vitis-AI because PyXIR can&#39;t be foundCall Stack (most recent call first):  CMakeLists.txt:479 (include)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  在tensorflow环境下不会报错，两者python版本一致（3.6）。在python命令行中尝试<strong>import pyxir</strong>，同样也是在tensorflow环境中正确导入而在pytorch环境中提示无法找到。暂时没有解决。最终还是在tf环境下完成了TVM的安装。</p><h3 id="二、target环境搭建">二、target环境搭建</h3><p>  一开始没有找到官方文档（或者说不是适配的官方文档，<a href="https://www.xilinx.com/htmldocs/vitis_ai/1_4/installation.html#ariaid-title8">https://www.xilinx.com/htmldocs/vitis_ai/1_4/installation.html#ariaid-title8</a>  这篇Xilinx官网的文档显然不适合本次搭建用的<strong>image</strong>,同时这个链接的教程中提供的<strong>image</strong>就是要用的）。遇到了一些问题：时间不符合（newly created file is older…），wegt的时候certificate不被信任（直接在命令后加上 --no-check-certificate即可）。部分问题可通过走下面的流程避免：<br>  正确的流程是跟着github上的指南：<a href="https://github.com/Xilinx/Vitis-AI/blob/master/external/tvm/docs/running_on_zynq.md">https://github.com/Xilinx/Vitis-AI/blob/master/external/tvm/docs/running_on_zynq.md</a>  其中提供了petalinux setup script。这个脚本给出了完整的安装TVM的runtime的流程。<br>  需要注意的是：</p><pre><code># Set date/timedate -s &quot;$(wget -qSO- --max-redirect=0 google.com 2&gt;&amp;1 | grep Date: | cut -d' ' -f5-8)Z&quot;# 设置时间，如果没有科学上网，把谷歌网址改成百度。# INSTALL PIP3sudo dnf install -y python3-pip  由于image中是不带pip的，脚本中提供了如上命令去安装pip3；但是这个命令会转到Xilinx的某个404网站，即 http://petalinux.xilinx.com/sswreleases/rel-v2021.1/generic/rpm/zynqmpeg/repodata/repomd.xml因此用还是用python3 get-pip.py的方式本地编译生成pip3，这个过程将会持续很长时间</code></pre><p>  此外，由于过程中使用了一些gitee上同步的仓库，部分文件内容不一致，导致最终<strong>cmake</strong>过程中报错：declaration conflict。 需要找到相应第三方包，和官方仓库比对，覆盖。<br>  下面是安装结束后导入tvm以及pyxir均无问题。<br><img src="https://s1.ax1x.com/2022/03/13/bbDwUf.png" alt="图片描述"></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本篇主要记录一下TVM环境搭建过程，FPGA开发板：zcu102&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="TVM" scheme="https://naughtyrabbit.github.io/categories/TVM/"/>
    
    
    <category term="TVM" scheme="https://naughtyrabbit.github.io/tags/TVM/"/>
    
  </entry>
  
</feed>
